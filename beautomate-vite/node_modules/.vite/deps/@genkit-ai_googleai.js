import {
  ZodFirstPartyTypeKind,
  external_exports
} from "./chunk-SLXWM3K3.js";
import {
  lib_exports,
  require_action,
  require_action2,
  require_ajv,
  require_async_context,
  require_background_action,
  require_browser,
  require_common,
  require_context,
  require_crypto,
  require_dist,
  require_document,
  require_embedder,
  require_error,
  require_exporter,
  require_flow,
  require_fs,
  require_genkit,
  require_instrumentation,
  require_logging,
  require_logging2,
  require_middleware,
  require_model,
  require_model_types,
  require_node_perf_hooks,
  require_plugin,
  require_reflection,
  require_retriever,
  require_schema,
  require_telemetryTypes,
  require_tracing,
  require_types,
  require_utils,
  require_version
} from "./chunk-RVJCDNHM.js";
import "./chunk-6OUVC2SX.js";
import {
  __commonJS,
  __export,
  __publicField,
  __reExport,
  __toESM
} from "./chunk-3Q7NSNN6.js";

// node_modules/genkit/lib/index.js
var require_lib = __commonJS({
  "node_modules/genkit/lib/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport2 = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var index_exports = {};
    __export2(index_exports, {
      Genkit: () => import_genkit2.Genkit,
      genkit: () => import_genkit2.genkit
    });
    module.exports = __toCommonJS(index_exports);
    __reExport2(index_exports, require_common(), module.exports);
    var import_genkit2 = require_genkit();
  }
});

// node_modules/@genkit-ai/googleai/lib/common.js
var require_common2 = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/common.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var common_exports = {};
    __export2(common_exports, {
      getApiKeyFromEnvVar: () => getApiKeyFromEnvVar2,
      getGenkitClientHeader: () => getGenkitClientHeader
    });
    module.exports = __toCommonJS(common_exports);
    var import_genkit2 = require_lib();
    var import_process = __toESM2(require_browser());
    function getApiKeyFromEnvVar2() {
      return import_process.default.env.GEMINI_API_KEY || import_process.default.env.GOOGLE_API_KEY || import_process.default.env.GOOGLE_GENAI_API_KEY;
    }
    function getGenkitClientHeader() {
      if (import_process.default.env.MONOSPACE_ENV == "true") {
        return (0, import_genkit2.getClientHeader)() + " firebase-studio-vm";
      }
      return (0, import_genkit2.getClientHeader)();
    }
  }
});

// node_modules/@google/generative-ai/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@google/generative-ai/dist/index.js"(exports) {
    "use strict";
    exports.SchemaType = void 0;
    (function(SchemaType) {
      SchemaType["STRING"] = "string";
      SchemaType["NUMBER"] = "number";
      SchemaType["INTEGER"] = "integer";
      SchemaType["BOOLEAN"] = "boolean";
      SchemaType["ARRAY"] = "array";
      SchemaType["OBJECT"] = "object";
    })(exports.SchemaType || (exports.SchemaType = {}));
    exports.ExecutableCodeLanguage = void 0;
    (function(ExecutableCodeLanguage) {
      ExecutableCodeLanguage["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
      ExecutableCodeLanguage["PYTHON"] = "python";
    })(exports.ExecutableCodeLanguage || (exports.ExecutableCodeLanguage = {}));
    exports.Outcome = void 0;
    (function(Outcome) {
      Outcome["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
      Outcome["OUTCOME_OK"] = "outcome_ok";
      Outcome["OUTCOME_FAILED"] = "outcome_failed";
      Outcome["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
    })(exports.Outcome || (exports.Outcome = {}));
    var POSSIBLE_ROLES = ["user", "model", "function", "system"];
    exports.HarmCategory = void 0;
    (function(HarmCategory) {
      HarmCategory["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
      HarmCategory["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
      HarmCategory["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
      HarmCategory["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
      HarmCategory["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
      HarmCategory["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
    })(exports.HarmCategory || (exports.HarmCategory = {}));
    exports.HarmBlockThreshold = void 0;
    (function(HarmBlockThreshold) {
      HarmBlockThreshold["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
      HarmBlockThreshold["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      HarmBlockThreshold["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      HarmBlockThreshold["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      HarmBlockThreshold["BLOCK_NONE"] = "BLOCK_NONE";
    })(exports.HarmBlockThreshold || (exports.HarmBlockThreshold = {}));
    exports.HarmProbability = void 0;
    (function(HarmProbability) {
      HarmProbability["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
      HarmProbability["NEGLIGIBLE"] = "NEGLIGIBLE";
      HarmProbability["LOW"] = "LOW";
      HarmProbability["MEDIUM"] = "MEDIUM";
      HarmProbability["HIGH"] = "HIGH";
    })(exports.HarmProbability || (exports.HarmProbability = {}));
    exports.BlockReason = void 0;
    (function(BlockReason) {
      BlockReason["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
      BlockReason["SAFETY"] = "SAFETY";
      BlockReason["OTHER"] = "OTHER";
    })(exports.BlockReason || (exports.BlockReason = {}));
    exports.FinishReason = void 0;
    (function(FinishReason) {
      FinishReason["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
      FinishReason["STOP"] = "STOP";
      FinishReason["MAX_TOKENS"] = "MAX_TOKENS";
      FinishReason["SAFETY"] = "SAFETY";
      FinishReason["RECITATION"] = "RECITATION";
      FinishReason["LANGUAGE"] = "LANGUAGE";
      FinishReason["BLOCKLIST"] = "BLOCKLIST";
      FinishReason["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      FinishReason["SPII"] = "SPII";
      FinishReason["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      FinishReason["OTHER"] = "OTHER";
    })(exports.FinishReason || (exports.FinishReason = {}));
    exports.TaskType = void 0;
    (function(TaskType) {
      TaskType["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
      TaskType["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
      TaskType["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
      TaskType["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
      TaskType["CLASSIFICATION"] = "CLASSIFICATION";
      TaskType["CLUSTERING"] = "CLUSTERING";
    })(exports.TaskType || (exports.TaskType = {}));
    exports.FunctionCallingMode = void 0;
    (function(FunctionCallingMode) {
      FunctionCallingMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      FunctionCallingMode["AUTO"] = "AUTO";
      FunctionCallingMode["ANY"] = "ANY";
      FunctionCallingMode["NONE"] = "NONE";
    })(exports.FunctionCallingMode || (exports.FunctionCallingMode = {}));
    exports.DynamicRetrievalMode = void 0;
    (function(DynamicRetrievalMode) {
      DynamicRetrievalMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      DynamicRetrievalMode["MODE_DYNAMIC"] = "MODE_DYNAMIC";
    })(exports.DynamicRetrievalMode || (exports.DynamicRetrievalMode = {}));
    var GoogleGenerativeAIError = class extends Error {
      constructor(message) {
        super(`[GoogleGenerativeAI Error]: ${message}`);
      }
    };
    var GoogleGenerativeAIResponseError = class extends GoogleGenerativeAIError {
      constructor(message, response) {
        super(message);
        this.response = response;
      }
    };
    var GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
      constructor(message, status, statusText, errorDetails) {
        super(message);
        this.status = status;
        this.statusText = statusText;
        this.errorDetails = errorDetails;
      }
    };
    var GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
    };
    var GoogleGenerativeAIAbortError = class extends GoogleGenerativeAIError {
    };
    var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
    var DEFAULT_API_VERSION = "v1beta";
    var PACKAGE_VERSION = "0.24.1";
    var PACKAGE_LOG_HEADER = "genai-js";
    var Task;
    (function(Task2) {
      Task2["GENERATE_CONTENT"] = "generateContent";
      Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
      Task2["COUNT_TOKENS"] = "countTokens";
      Task2["EMBED_CONTENT"] = "embedContent";
      Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
    })(Task || (Task = {}));
    var RequestUrl = class {
      constructor(model2, task, apiKey2, stream, requestOptions) {
        this.model = model2;
        this.task = task;
        this.apiKey = apiKey2;
        this.stream = stream;
        this.requestOptions = requestOptions;
      }
      toString() {
        var _a, _b;
        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
        let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
        if (this.stream) {
          url += "?alt=sse";
        }
        return url;
      }
    };
    function getClientHeaders(requestOptions) {
      const clientHeaders = [];
      if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
        clientHeaders.push(requestOptions.apiClient);
      }
      clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
      return clientHeaders.join(" ");
    }
    async function getHeaders(url) {
      var _a;
      const headers = new Headers();
      headers.append("Content-Type", "application/json");
      headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
      headers.append("x-goog-api-key", url.apiKey);
      let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;
      if (customHeaders) {
        if (!(customHeaders instanceof Headers)) {
          try {
            customHeaders = new Headers(customHeaders);
          } catch (e) {
            throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
          }
        }
        for (const [headerName, headerValue] of customHeaders.entries()) {
          if (headerName === "x-goog-api-key") {
            throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
          } else if (headerName === "x-goog-api-client") {
            throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
          }
          headers.append(headerName, headerValue);
        }
      }
      return headers;
    }
    async function constructModelRequest(model2, task, apiKey2, stream, body, requestOptions) {
      const url = new RequestUrl(model2, task, apiKey2, stream, requestOptions);
      return {
        url: url.toString(),
        fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
      };
    }
    async function makeModelRequest(model2, task, apiKey2, stream, body, requestOptions = {}, fetchFn = fetch) {
      const { url, fetchOptions } = await constructModelRequest(model2, task, apiKey2, stream, body, requestOptions);
      return makeRequest(url, fetchOptions, fetchFn);
    }
    async function makeRequest(url, fetchOptions, fetchFn = fetch) {
      let response;
      try {
        response = await fetchFn(url, fetchOptions);
      } catch (e) {
        handleResponseError(e, url);
      }
      if (!response.ok) {
        await handleResponseNotOk(response, url);
      }
      return response;
    }
    function handleResponseError(e, url) {
      let err = e;
      if (err.name === "AbortError") {
        err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);
        err.stack = e.stack;
      } else if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
        err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
        err.stack = e.stack;
      }
      throw err;
    }
    async function handleResponseNotOk(response, url) {
      let message = "";
      let errorDetails;
      try {
        const json = await response.json();
        message = json.error.message;
        if (json.error.details) {
          message += ` ${JSON.stringify(json.error.details)}`;
          errorDetails = json.error.details;
        }
      } catch (e) {
      }
      throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
    }
    function buildFetchOptions(requestOptions) {
      const fetchOptions = {};
      if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== void 0 || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
        const controller = new AbortController();
        if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
          setTimeout(() => controller.abort(), requestOptions.timeout);
        }
        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) {
          requestOptions.signal.addEventListener("abort", () => {
            controller.abort();
          });
        }
        fetchOptions.signal = controller.signal;
      }
      return fetchOptions;
    }
    function addHelpers(response) {
      response.text = () => {
        if (response.candidates && response.candidates.length > 0) {
          if (response.candidates.length > 1) {
            console.warn(`This response had ${response.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`);
          }
          if (hadBadFinishReason(response.candidates[0])) {
            throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
          }
          return getText(response);
        } else if (response.promptFeedback) {
          throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
        }
        return "";
      };
      response.functionCall = () => {
        if (response.candidates && response.candidates.length > 0) {
          if (response.candidates.length > 1) {
            console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
          }
          if (hadBadFinishReason(response.candidates[0])) {
            throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
          }
          console.warn(`response.functionCall() is deprecated. Use response.functionCalls() instead.`);
          return getFunctionCalls(response)[0];
        } else if (response.promptFeedback) {
          throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
        }
        return void 0;
      };
      response.functionCalls = () => {
        if (response.candidates && response.candidates.length > 0) {
          if (response.candidates.length > 1) {
            console.warn(`This response had ${response.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
          }
          if (hadBadFinishReason(response.candidates[0])) {
            throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
          }
          return getFunctionCalls(response);
        } else if (response.promptFeedback) {
          throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
        }
        return void 0;
      };
      return response;
    }
    function getText(response) {
      var _a, _b, _c, _d;
      const textStrings = [];
      if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
          if (part.text) {
            textStrings.push(part.text);
          }
          if (part.executableCode) {
            textStrings.push("\n```" + part.executableCode.language + "\n" + part.executableCode.code + "\n```\n");
          }
          if (part.codeExecutionResult) {
            textStrings.push("\n```\n" + part.codeExecutionResult.output + "\n```\n");
          }
        }
      }
      if (textStrings.length > 0) {
        return textStrings.join("");
      } else {
        return "";
      }
    }
    function getFunctionCalls(response) {
      var _a, _b, _c, _d;
      const functionCalls = [];
      if ((_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0].content) === null || _b === void 0 ? void 0 : _b.parts) {
        for (const part of (_d = (_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0].content) === null || _d === void 0 ? void 0 : _d.parts) {
          if (part.functionCall) {
            functionCalls.push(part.functionCall);
          }
        }
      }
      if (functionCalls.length > 0) {
        return functionCalls;
      } else {
        return void 0;
      }
    }
    var badFinishReasons = [
      exports.FinishReason.RECITATION,
      exports.FinishReason.SAFETY,
      exports.FinishReason.LANGUAGE
    ];
    function hadBadFinishReason(candidate) {
      return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
    }
    function formatBlockErrorMessage(response) {
      var _a, _b, _c;
      let message = "";
      if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
        message += "Response was blocked";
        if ((_a = response.promptFeedback) === null || _a === void 0 ? void 0 : _a.blockReason) {
          message += ` due to ${response.promptFeedback.blockReason}`;
        }
        if ((_b = response.promptFeedback) === null || _b === void 0 ? void 0 : _b.blockReasonMessage) {
          message += `: ${response.promptFeedback.blockReasonMessage}`;
        }
      } else if ((_c = response.candidates) === null || _c === void 0 ? void 0 : _c[0]) {
        const firstCandidate = response.candidates[0];
        if (hadBadFinishReason(firstCandidate)) {
          message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
          if (firstCandidate.finishMessage) {
            message += `: ${firstCandidate.finishMessage}`;
          }
        }
      }
      return message;
    }
    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }
    var responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
    function processStream(response) {
      const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
      const responseStream = getResponseStream(inputStream);
      const [stream1, stream2] = responseStream.tee();
      return {
        stream: generateResponseSequence(stream1),
        response: getResponsePromise(stream2)
      };
    }
    async function getResponsePromise(stream) {
      const allResponses = [];
      const reader = stream.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          return addHelpers(aggregateResponses(allResponses));
        }
        allResponses.push(value);
      }
    }
    function generateResponseSequence(stream) {
      return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
        const reader = stream.getReader();
        while (true) {
          const { value, done } = yield __await(reader.read());
          if (done) {
            break;
          }
          yield yield __await(addHelpers(value));
        }
      });
    }
    function getResponseStream(inputStream) {
      const reader = inputStream.getReader();
      const stream = new ReadableStream({
        start(controller) {
          let currentText = "";
          return pump();
          function pump() {
            return reader.read().then(({ value, done }) => {
              if (done) {
                if (currentText.trim()) {
                  controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
                  return;
                }
                controller.close();
                return;
              }
              currentText += value;
              let match = currentText.match(responseLineRE);
              let parsedResponse;
              while (match) {
                try {
                  parsedResponse = JSON.parse(match[1]);
                } catch (e) {
                  controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
                  return;
                }
                controller.enqueue(parsedResponse);
                currentText = currentText.substring(match[0].length);
                match = currentText.match(responseLineRE);
              }
              return pump();
            }).catch((e) => {
              let err = e;
              err.stack = e.stack;
              if (err.name === "AbortError") {
                err = new GoogleGenerativeAIAbortError("Request aborted when reading from the stream");
              } else {
                err = new GoogleGenerativeAIError("Error reading from the stream");
              }
              throw err;
            });
          }
        }
      });
      return stream;
    }
    function aggregateResponses(responses) {
      const lastResponse = responses[responses.length - 1];
      const aggregatedResponse = {
        promptFeedback: lastResponse === null || lastResponse === void 0 ? void 0 : lastResponse.promptFeedback
      };
      for (const response of responses) {
        if (response.candidates) {
          let candidateIndex = 0;
          for (const candidate of response.candidates) {
            if (!aggregatedResponse.candidates) {
              aggregatedResponse.candidates = [];
            }
            if (!aggregatedResponse.candidates[candidateIndex]) {
              aggregatedResponse.candidates[candidateIndex] = {
                index: candidateIndex
              };
            }
            aggregatedResponse.candidates[candidateIndex].citationMetadata = candidate.citationMetadata;
            aggregatedResponse.candidates[candidateIndex].groundingMetadata = candidate.groundingMetadata;
            aggregatedResponse.candidates[candidateIndex].finishReason = candidate.finishReason;
            aggregatedResponse.candidates[candidateIndex].finishMessage = candidate.finishMessage;
            aggregatedResponse.candidates[candidateIndex].safetyRatings = candidate.safetyRatings;
            if (candidate.content && candidate.content.parts) {
              if (!aggregatedResponse.candidates[candidateIndex].content) {
                aggregatedResponse.candidates[candidateIndex].content = {
                  role: candidate.content.role || "user",
                  parts: []
                };
              }
              const newPart = {};
              for (const part of candidate.content.parts) {
                if (part.text) {
                  newPart.text = part.text;
                }
                if (part.functionCall) {
                  newPart.functionCall = part.functionCall;
                }
                if (part.executableCode) {
                  newPart.executableCode = part.executableCode;
                }
                if (part.codeExecutionResult) {
                  newPart.codeExecutionResult = part.codeExecutionResult;
                }
                if (Object.keys(newPart).length === 0) {
                  newPart.text = "";
                }
                aggregatedResponse.candidates[candidateIndex].content.parts.push(newPart);
              }
            }
          }
          candidateIndex++;
        }
        if (response.usageMetadata) {
          aggregatedResponse.usageMetadata = response.usageMetadata;
        }
      }
      return aggregatedResponse;
    }
    async function generateContentStream(apiKey2, model2, params, requestOptions) {
      const response = await makeModelRequest(
        model2,
        Task.STREAM_GENERATE_CONTENT,
        apiKey2,
        /* stream */
        true,
        JSON.stringify(params),
        requestOptions
      );
      return processStream(response);
    }
    async function generateContent(apiKey2, model2, params, requestOptions) {
      const response = await makeModelRequest(
        model2,
        Task.GENERATE_CONTENT,
        apiKey2,
        /* stream */
        false,
        JSON.stringify(params),
        requestOptions
      );
      const responseJson = await response.json();
      const enhancedResponse = addHelpers(responseJson);
      return {
        response: enhancedResponse
      };
    }
    function formatSystemInstruction(input) {
      if (input == null) {
        return void 0;
      } else if (typeof input === "string") {
        return { role: "system", parts: [{ text: input }] };
      } else if (input.text) {
        return { role: "system", parts: [input] };
      } else if (input.parts) {
        if (!input.role) {
          return { role: "system", parts: input.parts };
        } else {
          return input;
        }
      }
    }
    function formatNewContent(request) {
      let newParts = [];
      if (typeof request === "string") {
        newParts = [{ text: request }];
      } else {
        for (const partOrString of request) {
          if (typeof partOrString === "string") {
            newParts.push({ text: partOrString });
          } else {
            newParts.push(partOrString);
          }
        }
      }
      return assignRoleToPartsAndValidateSendMessageRequest(newParts);
    }
    function assignRoleToPartsAndValidateSendMessageRequest(parts) {
      const userContent = { role: "user", parts: [] };
      const functionContent = { role: "function", parts: [] };
      let hasUserContent = false;
      let hasFunctionContent = false;
      for (const part of parts) {
        if ("functionResponse" in part) {
          functionContent.parts.push(part);
          hasFunctionContent = true;
        } else {
          userContent.parts.push(part);
          hasUserContent = true;
        }
      }
      if (hasUserContent && hasFunctionContent) {
        throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
      }
      if (!hasUserContent && !hasFunctionContent) {
        throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
      }
      if (hasUserContent) {
        return userContent;
      }
      return functionContent;
    }
    function formatCountTokensInput(params, modelParams) {
      var _a;
      let formattedGenerateContentRequest = {
        model: modelParams === null || modelParams === void 0 ? void 0 : modelParams.model,
        generationConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.generationConfig,
        safetySettings: modelParams === null || modelParams === void 0 ? void 0 : modelParams.safetySettings,
        tools: modelParams === null || modelParams === void 0 ? void 0 : modelParams.tools,
        toolConfig: modelParams === null || modelParams === void 0 ? void 0 : modelParams.toolConfig,
        systemInstruction: modelParams === null || modelParams === void 0 ? void 0 : modelParams.systemInstruction,
        cachedContent: (_a = modelParams === null || modelParams === void 0 ? void 0 : modelParams.cachedContent) === null || _a === void 0 ? void 0 : _a.name,
        contents: []
      };
      const containsGenerateContentRequest = params.generateContentRequest != null;
      if (params.contents) {
        if (containsGenerateContentRequest) {
          throw new GoogleGenerativeAIRequestInputError("CountTokensRequest must have one of contents or generateContentRequest, not both.");
        }
        formattedGenerateContentRequest.contents = params.contents;
      } else if (containsGenerateContentRequest) {
        formattedGenerateContentRequest = Object.assign(Object.assign({}, formattedGenerateContentRequest), params.generateContentRequest);
      } else {
        const content = formatNewContent(params);
        formattedGenerateContentRequest.contents = [content];
      }
      return { generateContentRequest: formattedGenerateContentRequest };
    }
    function formatGenerateContentInput(params) {
      let formattedRequest;
      if (params.contents) {
        formattedRequest = params;
      } else {
        const content = formatNewContent(params);
        formattedRequest = { contents: [content] };
      }
      if (params.systemInstruction) {
        formattedRequest.systemInstruction = formatSystemInstruction(params.systemInstruction);
      }
      return formattedRequest;
    }
    function formatEmbedContentInput(params) {
      if (typeof params === "string" || Array.isArray(params)) {
        const content = formatNewContent(params);
        return { content };
      }
      return params;
    }
    var VALID_PART_FIELDS = [
      "text",
      "inlineData",
      "functionCall",
      "functionResponse",
      "executableCode",
      "codeExecutionResult"
    ];
    var VALID_PARTS_PER_ROLE = {
      user: ["text", "inlineData"],
      function: ["functionResponse"],
      model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
      // System instructions shouldn't be in history anyway.
      system: ["text"]
    };
    function validateChatHistory(history) {
      let prevContent = false;
      for (const currContent of history) {
        const { role, parts } = currContent;
        if (!prevContent && role !== "user") {
          throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
        }
        if (!POSSIBLE_ROLES.includes(role)) {
          throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
        }
        if (!Array.isArray(parts)) {
          throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
        }
        if (parts.length === 0) {
          throw new GoogleGenerativeAIError("Each Content should have at least one part");
        }
        const countFields = {
          text: 0,
          inlineData: 0,
          functionCall: 0,
          functionResponse: 0,
          fileData: 0,
          executableCode: 0,
          codeExecutionResult: 0
        };
        for (const part of parts) {
          for (const key of VALID_PART_FIELDS) {
            if (key in part) {
              countFields[key] += 1;
            }
          }
        }
        const validParts = VALID_PARTS_PER_ROLE[role];
        for (const key of VALID_PART_FIELDS) {
          if (!validParts.includes(key) && countFields[key] > 0) {
            throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
          }
        }
        prevContent = true;
      }
    }
    function isValidResponse(response) {
      var _a;
      if (response.candidates === void 0 || response.candidates.length === 0) {
        return false;
      }
      const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;
      if (content === void 0) {
        return false;
      }
      if (content.parts === void 0 || content.parts.length === 0) {
        return false;
      }
      for (const part of content.parts) {
        if (part === void 0 || Object.keys(part).length === 0) {
          return false;
        }
        if (part.text !== void 0 && part.text === "") {
          return false;
        }
      }
      return true;
    }
    var SILENT_ERROR = "SILENT_ERROR";
    var ChatSession = class {
      constructor(apiKey2, model2, params, _requestOptions = {}) {
        this.model = model2;
        this.params = params;
        this._requestOptions = _requestOptions;
        this._history = [];
        this._sendPromise = Promise.resolve();
        this._apiKey = apiKey2;
        if (params === null || params === void 0 ? void 0 : params.history) {
          validateChatHistory(params.history);
          this._history = params.history;
        }
      }
      /**
       * Gets the chat history so far. Blocked prompts are not added to history.
       * Blocked candidates are not added to history, nor are the prompts that
       * generated them.
       */
      async getHistory() {
        await this._sendPromise;
        return this._history;
      }
      /**
       * Sends a chat message and receives a non-streaming
       * {@link GenerateContentResult}.
       *
       * Fields set in the optional {@link SingleRequestOptions} parameter will
       * take precedence over the {@link RequestOptions} values provided to
       * {@link GoogleGenerativeAI.getGenerativeModel }.
       */
      async sendMessage(request, requestOptions = {}) {
        var _a, _b, _c, _d, _e, _f;
        await this._sendPromise;
        const newContent = formatNewContent(request);
        const generateContentRequest = {
          safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
          generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
          tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
          toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
          systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
          cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
          contents: [...this._history, newContent]
        };
        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        let finalResult;
        this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions)).then((result) => {
          var _a2;
          if (isValidResponse(result.response)) {
            this._history.push(newContent);
            const responseContent = Object.assign({
              parts: [],
              // Response seems to come back without a role set.
              role: "model"
            }, (_a2 = result.response.candidates) === null || _a2 === void 0 ? void 0 : _a2[0].content);
            this._history.push(responseContent);
          } else {
            const blockErrorMessage = formatBlockErrorMessage(result.response);
            if (blockErrorMessage) {
              console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
            }
          }
          finalResult = result;
        }).catch((e) => {
          this._sendPromise = Promise.resolve();
          throw e;
        });
        await this._sendPromise;
        return finalResult;
      }
      /**
       * Sends a chat message and receives the response as a
       * {@link GenerateContentStreamResult} containing an iterable stream
       * and a response promise.
       *
       * Fields set in the optional {@link SingleRequestOptions} parameter will
       * take precedence over the {@link RequestOptions} values provided to
       * {@link GoogleGenerativeAI.getGenerativeModel }.
       */
      async sendMessageStream(request, requestOptions = {}) {
        var _a, _b, _c, _d, _e, _f;
        await this._sendPromise;
        const newContent = formatNewContent(request);
        const generateContentRequest = {
          safetySettings: (_a = this.params) === null || _a === void 0 ? void 0 : _a.safetySettings,
          generationConfig: (_b = this.params) === null || _b === void 0 ? void 0 : _b.generationConfig,
          tools: (_c = this.params) === null || _c === void 0 ? void 0 : _c.tools,
          toolConfig: (_d = this.params) === null || _d === void 0 ? void 0 : _d.toolConfig,
          systemInstruction: (_e = this.params) === null || _e === void 0 ? void 0 : _e.systemInstruction,
          cachedContent: (_f = this.params) === null || _f === void 0 ? void 0 : _f.cachedContent,
          contents: [...this._history, newContent]
        };
        const chatSessionRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, chatSessionRequestOptions);
        this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
          throw new Error(SILENT_ERROR);
        }).then((streamResult) => streamResult.response).then((response) => {
          if (isValidResponse(response)) {
            this._history.push(newContent);
            const responseContent = Object.assign({}, response.candidates[0].content);
            if (!responseContent.role) {
              responseContent.role = "model";
            }
            this._history.push(responseContent);
          } else {
            const blockErrorMessage = formatBlockErrorMessage(response);
            if (blockErrorMessage) {
              console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
            }
          }
        }).catch((e) => {
          if (e.message !== SILENT_ERROR) {
            console.error(e);
          }
        });
        return streamPromise;
      }
    };
    async function countTokens(apiKey2, model2, params, singleRequestOptions) {
      const response = await makeModelRequest(model2, Task.COUNT_TOKENS, apiKey2, false, JSON.stringify(params), singleRequestOptions);
      return response.json();
    }
    async function embedContent(apiKey2, model2, params, requestOptions) {
      const response = await makeModelRequest(model2, Task.EMBED_CONTENT, apiKey2, false, JSON.stringify(params), requestOptions);
      return response.json();
    }
    async function batchEmbedContents(apiKey2, model2, params, requestOptions) {
      const requestsWithModel = params.requests.map((request) => {
        return Object.assign(Object.assign({}, request), { model: model2 });
      });
      const response = await makeModelRequest(model2, Task.BATCH_EMBED_CONTENTS, apiKey2, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
      return response.json();
    }
    var GenerativeModel = class {
      constructor(apiKey2, modelParams, _requestOptions = {}) {
        this.apiKey = apiKey2;
        this._requestOptions = _requestOptions;
        if (modelParams.model.includes("/")) {
          this.model = modelParams.model;
        } else {
          this.model = `models/${modelParams.model}`;
        }
        this.generationConfig = modelParams.generationConfig || {};
        this.safetySettings = modelParams.safetySettings || [];
        this.tools = modelParams.tools;
        this.toolConfig = modelParams.toolConfig;
        this.systemInstruction = formatSystemInstruction(modelParams.systemInstruction);
        this.cachedContent = modelParams.cachedContent;
      }
      /**
       * Makes a single non-streaming call to the model
       * and returns an object containing a single {@link GenerateContentResponse}.
       *
       * Fields set in the optional {@link SingleRequestOptions} parameter will
       * take precedence over the {@link RequestOptions} values provided to
       * {@link GoogleGenerativeAI.getGenerativeModel }.
       */
      async generateContent(request, requestOptions = {}) {
        var _a;
        const formattedParams = formatGenerateContentInput(request);
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
      }
      /**
       * Makes a single streaming call to the model and returns an object
       * containing an iterable stream that iterates over all chunks in the
       * streaming response as well as a promise that returns the final
       * aggregated response.
       *
       * Fields set in the optional {@link SingleRequestOptions} parameter will
       * take precedence over the {@link RequestOptions} values provided to
       * {@link GoogleGenerativeAI.getGenerativeModel }.
       */
      async generateContentStream(request, requestOptions = {}) {
        var _a;
        const formattedParams = formatGenerateContentInput(request);
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, formattedParams), generativeModelRequestOptions);
      }
      /**
       * Gets a new {@link ChatSession} instance which can be used for
       * multi-turn chats.
       */
      startChat(startChatParams) {
        var _a;
        return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction, cachedContent: (_a = this.cachedContent) === null || _a === void 0 ? void 0 : _a.name }, startChatParams), this._requestOptions);
      }
      /**
       * Counts the tokens in the provided request.
       *
       * Fields set in the optional {@link SingleRequestOptions} parameter will
       * take precedence over the {@link RequestOptions} values provided to
       * {@link GoogleGenerativeAI.getGenerativeModel }.
       */
      async countTokens(request, requestOptions = {}) {
        const formattedParams = formatCountTokensInput(request, {
          model: this.model,
          generationConfig: this.generationConfig,
          safetySettings: this.safetySettings,
          tools: this.tools,
          toolConfig: this.toolConfig,
          systemInstruction: this.systemInstruction,
          cachedContent: this.cachedContent
        });
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return countTokens(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
      }
      /**
       * Embeds the provided content.
       *
       * Fields set in the optional {@link SingleRequestOptions} parameter will
       * take precedence over the {@link RequestOptions} values provided to
       * {@link GoogleGenerativeAI.getGenerativeModel }.
       */
      async embedContent(request, requestOptions = {}) {
        const formattedParams = formatEmbedContentInput(request);
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return embedContent(this.apiKey, this.model, formattedParams, generativeModelRequestOptions);
      }
      /**
       * Embeds an array of {@link EmbedContentRequest}s.
       *
       * Fields set in the optional {@link SingleRequestOptions} parameter will
       * take precedence over the {@link RequestOptions} values provided to
       * {@link GoogleGenerativeAI.getGenerativeModel }.
       */
      async batchEmbedContents(batchEmbedContentRequest, requestOptions = {}) {
        const generativeModelRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, generativeModelRequestOptions);
      }
    };
    var GoogleGenerativeAI = class {
      constructor(apiKey2) {
        this.apiKey = apiKey2;
      }
      /**
       * Gets a {@link GenerativeModel} instance for the provided model name.
       */
      getGenerativeModel(modelParams, requestOptions) {
        if (!modelParams.model) {
          throw new GoogleGenerativeAIError(`Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
        }
        return new GenerativeModel(this.apiKey, modelParams, requestOptions);
      }
      /**
       * Creates a {@link GenerativeModel} instance from provided content cache.
       */
      getGenerativeModelFromCachedContent(cachedContent, modelParams, requestOptions) {
        if (!cachedContent.name) {
          throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `name` field.");
        }
        if (!cachedContent.model) {
          throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
        }
        const disallowedDuplicates = ["model", "systemInstruction"];
        for (const key of disallowedDuplicates) {
          if ((modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) && cachedContent[key] && (modelParams === null || modelParams === void 0 ? void 0 : modelParams[key]) !== cachedContent[key]) {
            if (key === "model") {
              const modelParamsComp = modelParams.model.startsWith("models/") ? modelParams.model.replace("models/", "") : modelParams.model;
              const cachedContentComp = cachedContent.model.startsWith("models/") ? cachedContent.model.replace("models/", "") : cachedContent.model;
              if (modelParamsComp === cachedContentComp) {
                continue;
              }
            }
            throw new GoogleGenerativeAIRequestInputError(`Different value for "${key}" specified in modelParams (${modelParams[key]}) and cachedContent (${cachedContent[key]})`);
          }
        }
        const modelParamsFromCache = Object.assign(Object.assign({}, modelParams), { model: cachedContent.model, tools: cachedContent.tools, toolConfig: cachedContent.toolConfig, systemInstruction: cachedContent.systemInstruction, cachedContent });
        return new GenerativeModel(this.apiKey, modelParamsFromCache, requestOptions);
      }
    };
    exports.ChatSession = ChatSession;
    exports.GenerativeModel = GenerativeModel;
    exports.GoogleGenerativeAI = GoogleGenerativeAI;
    exports.GoogleGenerativeAIAbortError = GoogleGenerativeAIAbortError;
    exports.GoogleGenerativeAIError = GoogleGenerativeAIError;
    exports.GoogleGenerativeAIFetchError = GoogleGenerativeAIFetchError;
    exports.GoogleGenerativeAIRequestInputError = GoogleGenerativeAIRequestInputError;
    exports.GoogleGenerativeAIResponseError = GoogleGenerativeAIResponseError;
    exports.POSSIBLE_ROLES = POSSIBLE_ROLES;
  }
});

// node_modules/genkit/lib/embedder.js
var require_embedder2 = __commonJS({
  "node_modules/genkit/lib/embedder.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var embedder_exports = {};
    __export2(embedder_exports, {
      EmbedderInfoSchema: () => import_embedder3.EmbedderInfoSchema,
      embedderRef: () => import_embedder3.embedderRef
    });
    module.exports = __toCommonJS(embedder_exports);
    var import_embedder3 = require_embedder();
  }
});

// node_modules/@genkit-ai/googleai/lib/embedder.js
var require_embedder3 = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/embedder.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var embedder_exports = {};
    __export2(embedder_exports, {
      GeminiEmbeddingConfigSchema: () => GeminiEmbeddingConfigSchema2,
      SUPPORTED_MODELS: () => SUPPORTED_MODELS,
      TaskTypeSchema: () => TaskTypeSchema,
      defineGoogleAIEmbedder: () => defineGoogleAIEmbedder2,
      geminiEmbedding001: () => geminiEmbedding0012,
      textEmbedding004: () => textEmbedding0042,
      textEmbeddingGecko001: () => textEmbeddingGecko0012
    });
    module.exports = __toCommonJS(embedder_exports);
    var import_generative_ai = require_dist2();
    var import_genkit2 = require_lib();
    var import_embedder3 = require_embedder2();
    var import_common2 = require_common2();
    var TaskTypeSchema = import_genkit2.z.enum([
      "RETRIEVAL_DOCUMENT",
      "RETRIEVAL_QUERY",
      "SEMANTIC_SIMILARITY",
      "CLASSIFICATION",
      "CLUSTERING"
    ]);
    var GeminiEmbeddingConfigSchema2 = import_genkit2.z.object({
      /** Override the API key provided at plugin initialization. */
      apiKey: import_genkit2.z.string().optional(),
      /**
       * The `task_type` parameter is defined as the intended downstream application to help the model
       * produce better quality embeddings.
       **/
      taskType: TaskTypeSchema.optional(),
      title: import_genkit2.z.string().optional(),
      version: import_genkit2.z.string().optional(),
      /**
       * The `outputDimensionality` parameter allows you to specify the dimensionality of the embedding output.
       * By default, the model generates embeddings with 768 dimensions. Models such as
       * `text-embedding-004`, `text-embedding-005`, and `text-multilingual-embedding-002`
       * allow the output dimensionality to be adjusted between 1 and 768.
       * By selecting a smaller output dimensionality, users can save memory and storage space, leading to more efficient computations.
       **/
      outputDimensionality: import_genkit2.z.number().min(1).max(768).optional()
    });
    var textEmbeddingGecko0012 = (0, import_embedder3.embedderRef)({
      name: "googleai/embedding-001",
      configSchema: GeminiEmbeddingConfigSchema2,
      info: {
        dimensions: 768,
        label: "Google Gen AI - Text Embedding Gecko (Legacy)",
        supports: {
          input: ["text"]
        }
      }
    });
    var textEmbedding0042 = (0, import_embedder3.embedderRef)({
      name: "googleai/text-embedding-004",
      configSchema: GeminiEmbeddingConfigSchema2,
      info: {
        dimensions: 768,
        label: "Google Gen AI - Text Embedding 001",
        supports: {
          input: ["text"]
        }
      }
    });
    var geminiEmbedding0012 = (0, import_embedder3.embedderRef)({
      name: "googleai/gemini-embedding-001",
      configSchema: GeminiEmbeddingConfigSchema2,
      info: {
        dimensions: 768,
        label: "Google Gen AI - Gemini Embedding 001",
        supports: {
          input: ["text"]
        }
      }
    });
    var SUPPORTED_MODELS = {
      "embedding-001": textEmbeddingGecko0012,
      "text-embedding-004": textEmbedding0042,
      "gemini-embedding-001": geminiEmbedding0012
    };
    function defineGoogleAIEmbedder2(ai, name, pluginOptions) {
      let apiKey2;
      if (pluginOptions.apiKey !== false) {
        apiKey2 = (pluginOptions == null ? void 0 : pluginOptions.apiKey) || (0, import_common2.getApiKeyFromEnvVar)();
        if (!apiKey2)
          throw new Error(
            "Please pass in the API key or set either GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai"
          );
      }
      const embedder2 = SUPPORTED_MODELS[name] ?? (0, import_embedder3.embedderRef)({
        name,
        configSchema: GeminiEmbeddingConfigSchema2,
        info: {
          dimensions: 768,
          label: `Google AI - ${name}`,
          supports: {
            input: ["text", "image", "video"]
          }
        }
      });
      const apiModelName = embedder2.name.startsWith("googleai/") ? embedder2.name.substring("googleai/".length) : embedder2.name;
      return ai.defineEmbedder(
        {
          name: embedder2.name,
          configSchema: GeminiEmbeddingConfigSchema2,
          info: embedder2.info
        },
        async (input, options) => {
          var _a;
          if (pluginOptions.apiKey === false && !(options == null ? void 0 : options.apiKey)) {
            throw new import_genkit2.GenkitError({
              status: "INVALID_ARGUMENT",
              message: "GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time."
            });
          }
          const client = new import_generative_ai.GoogleGenerativeAI(
            (options == null ? void 0 : options.apiKey) || apiKey2
          ).getGenerativeModel({
            model: (options == null ? void 0 : options.version) || ((_a = embedder2.config) == null ? void 0 : _a.version) || embedder2.version || apiModelName
          });
          const embeddings = await Promise.all(
            input.map(async (doc) => {
              const response = await client.embedContent({
                taskType: options == null ? void 0 : options.taskType,
                title: options == null ? void 0 : options.title,
                content: {
                  role: "",
                  parts: [{ text: doc.text }]
                },
                outputDimensionality: options == null ? void 0 : options.outputDimensionality
              });
              const values = response.embedding.values;
              return { embedding: values };
            })
          );
          return { embeddings };
        }
      );
    }
  }
});

// node_modules/genkit/lib/model.js
var require_model2 = __commonJS({
  "node_modules/genkit/lib/model.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var model_exports2 = {};
    __export2(model_exports2, {
      CandidateErrorSchema: () => import_model4.CandidateErrorSchema,
      CandidateSchema: () => import_model4.CandidateSchema,
      CustomPartSchema: () => import_model4.CustomPartSchema,
      DataPartSchema: () => import_model4.DataPartSchema,
      GenerateRequestSchema: () => import_model4.GenerateRequestSchema,
      GenerateResponseChunkSchema: () => import_model4.GenerateResponseChunkSchema,
      GenerateResponseSchema: () => import_model4.GenerateResponseSchema,
      GenerationCommonConfigDescriptions: () => import_model4.GenerationCommonConfigDescriptions,
      GenerationCommonConfigSchema: () => import_model4.GenerationCommonConfigSchema,
      GenerationUsageSchema: () => import_model4.GenerationUsageSchema,
      MediaPartSchema: () => import_model4.MediaPartSchema,
      MessageSchema: () => import_model4.MessageSchema,
      ModelInfoSchema: () => import_model4.ModelInfoSchema,
      ModelRequestSchema: () => import_model4.ModelRequestSchema,
      ModelResponseSchema: () => import_model4.ModelResponseSchema,
      PartSchema: () => import_model4.PartSchema,
      RoleSchema: () => import_model4.RoleSchema,
      TextPartSchema: () => import_model4.TextPartSchema,
      ToolDefinitionSchema: () => import_model4.ToolDefinitionSchema,
      ToolRequestPartSchema: () => import_model4.ToolRequestPartSchema,
      ToolResponsePartSchema: () => import_model4.ToolResponsePartSchema,
      getBasicUsageStats: () => import_model4.getBasicUsageStats,
      modelRef: () => import_model4.modelRef,
      simulateConstrainedGeneration: () => import_model4.simulateConstrainedGeneration
    });
    module.exports = __toCommonJS(model_exports2);
    var import_model4 = require_model();
  }
});

// node_modules/genkit/lib/middleware.js
var require_middleware2 = __commonJS({
  "node_modules/genkit/lib/middleware.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var middleware_exports = {};
    __export2(middleware_exports, {
      augmentWithContext: () => import_middleware2.augmentWithContext,
      downloadRequestMedia: () => import_middleware2.downloadRequestMedia,
      simulateSystemPrompt: () => import_middleware2.simulateSystemPrompt,
      validateSupport: () => import_middleware2.validateSupport
    });
    module.exports = __toCommonJS(middleware_exports);
    var import_middleware2 = require_middleware();
  }
});

// node_modules/@google/generative-ai/dist/server/index.js
var require_server = __commonJS({
  "node_modules/@google/generative-ai/dist/server/index.js"(exports) {
    "use strict";
    var fs = require_fs();
    var GoogleGenerativeAIError = class extends Error {
      constructor(message) {
        super(`[GoogleGenerativeAI Error]: ${message}`);
      }
    };
    var GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
      constructor(message, status, statusText, errorDetails) {
        super(message);
        this.status = status;
        this.statusText = statusText;
        this.errorDetails = errorDetails;
      }
    };
    var GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
    };
    var GoogleGenerativeAIAbortError = class extends GoogleGenerativeAIError {
    };
    var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
    var DEFAULT_API_VERSION = "v1beta";
    var PACKAGE_VERSION = "0.24.1";
    var PACKAGE_LOG_HEADER = "genai-js";
    var Task;
    (function(Task2) {
      Task2["GENERATE_CONTENT"] = "generateContent";
      Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
      Task2["COUNT_TOKENS"] = "countTokens";
      Task2["EMBED_CONTENT"] = "embedContent";
      Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
    })(Task || (Task = {}));
    function getClientHeaders(requestOptions) {
      const clientHeaders = [];
      if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
        clientHeaders.push(requestOptions.apiClient);
      }
      clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
      return clientHeaders.join(" ");
    }
    async function makeRequest(url, fetchOptions, fetchFn = fetch) {
      let response;
      try {
        response = await fetchFn(url, fetchOptions);
      } catch (e) {
        handleResponseError(e, url);
      }
      if (!response.ok) {
        await handleResponseNotOk(response, url);
      }
      return response;
    }
    function handleResponseError(e, url) {
      let err = e;
      if (err.name === "AbortError") {
        err = new GoogleGenerativeAIAbortError(`Request aborted when fetching ${url.toString()}: ${e.message}`);
        err.stack = e.stack;
      } else if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
        err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
        err.stack = e.stack;
      }
      throw err;
    }
    async function handleResponseNotOk(response, url) {
      let message = "";
      let errorDetails;
      try {
        const json = await response.json();
        message = json.error.message;
        if (json.error.details) {
          message += ` ${JSON.stringify(json.error.details)}`;
          errorDetails = json.error.details;
        }
      } catch (e) {
      }
      throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
    }
    var RpcTask;
    (function(RpcTask2) {
      RpcTask2["UPLOAD"] = "upload";
      RpcTask2["LIST"] = "list";
      RpcTask2["GET"] = "get";
      RpcTask2["DELETE"] = "delete";
      RpcTask2["UPDATE"] = "update";
      RpcTask2["CREATE"] = "create";
    })(RpcTask || (RpcTask = {}));
    var taskToMethod = {
      [RpcTask.UPLOAD]: "POST",
      [RpcTask.LIST]: "GET",
      [RpcTask.GET]: "GET",
      [RpcTask.DELETE]: "DELETE",
      [RpcTask.UPDATE]: "PATCH",
      [RpcTask.CREATE]: "POST"
    };
    var ServerRequestUrl = class {
      constructor(task, apiKey2, requestOptions) {
        this.task = task;
        this.apiKey = apiKey2;
        this.requestOptions = requestOptions;
      }
      appendPath(path) {
        this._url.pathname = this._url.pathname + `/${path}`;
      }
      appendParam(key, value) {
        this._url.searchParams.append(key, value);
      }
      toString() {
        return this._url.toString();
      }
    };
    var CachedContentUrl = class extends ServerRequestUrl {
      constructor(task, apiKey2, requestOptions) {
        var _a, _b;
        super(task, apiKey2, requestOptions);
        this.task = task;
        this.apiKey = apiKey2;
        this.requestOptions = requestOptions;
        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
        let initialUrl = baseUrl;
        initialUrl += `/${apiVersion}/cachedContents`;
        this._url = new URL(initialUrl);
      }
    };
    var FilesRequestUrl = class extends ServerRequestUrl {
      constructor(task, apiKey2, requestOptions) {
        var _a, _b;
        super(task, apiKey2, requestOptions);
        this.task = task;
        this.apiKey = apiKey2;
        this.requestOptions = requestOptions;
        const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
        const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
        let initialUrl = baseUrl;
        if (this.task === RpcTask.UPLOAD) {
          initialUrl += `/upload`;
        }
        initialUrl += `/${apiVersion}/files`;
        this._url = new URL(initialUrl);
      }
    };
    function getHeaders(url) {
      var _a;
      const headers = new Headers();
      headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
      headers.append("x-goog-api-key", url.apiKey);
      let customHeaders = (_a = url.requestOptions) === null || _a === void 0 ? void 0 : _a.customHeaders;
      if (customHeaders) {
        if (!(customHeaders instanceof Headers)) {
          try {
            customHeaders = new Headers(customHeaders);
          } catch (e) {
            throw new GoogleGenerativeAIRequestInputError(`unable to convert customHeaders value ${JSON.stringify(customHeaders)} to Headers: ${e.message}`);
          }
        }
        for (const [headerName, headerValue] of customHeaders.entries()) {
          if (headerName === "x-goog-api-key") {
            throw new GoogleGenerativeAIRequestInputError(`Cannot set reserved header name ${headerName}`);
          } else if (headerName === "x-goog-api-client") {
            throw new GoogleGenerativeAIRequestInputError(`Header name ${headerName} can only be set using the apiClient field`);
          }
          headers.append(headerName, headerValue);
        }
      }
      return headers;
    }
    async function makeServerRequest(url, headers, body, fetchFn = fetch) {
      const requestInit = {
        method: taskToMethod[url.task],
        headers
      };
      if (body) {
        requestInit.body = body;
      }
      const signal = getSignal(url.requestOptions);
      if (signal) {
        requestInit.signal = signal;
      }
      return makeRequest(url.toString(), requestInit, fetchFn);
    }
    function getSignal(requestOptions) {
      if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== void 0 || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
        const controller = new AbortController();
        if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
          setTimeout(() => controller.abort(), requestOptions.timeout);
        }
        if (requestOptions.signal) {
          requestOptions.signal.addEventListener("abort", () => {
            controller.abort();
          });
        }
        return controller.signal;
      }
    }
    var GoogleAIFileManager = class {
      constructor(apiKey2, _requestOptions = {}) {
        this.apiKey = apiKey2;
        this._requestOptions = _requestOptions;
      }
      /**
       * Upload a file.
       */
      async uploadFile(fileData, fileMetadata) {
        const file = fileData instanceof Buffer ? fileData : fs.readFileSync(fileData);
        const url = new FilesRequestUrl(RpcTask.UPLOAD, this.apiKey, this._requestOptions);
        const uploadHeaders = getHeaders(url);
        const boundary = generateBoundary();
        uploadHeaders.append("X-Goog-Upload-Protocol", "multipart");
        uploadHeaders.append("Content-Type", `multipart/related; boundary=${boundary}`);
        const uploadMetadata = getUploadMetadata(fileMetadata);
        const metadataString = JSON.stringify({ file: uploadMetadata });
        const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + fileMetadata.mimeType + "\r\n\r\n";
        const postBlobPart = "\r\n--" + boundary + "--";
        const blob = new Blob([preBlobPart, file, postBlobPart]);
        const response = await makeServerRequest(url, uploadHeaders, blob);
        return response.json();
      }
      /**
       * List all uploaded files.
       *
       * Any fields set in the optional {@link SingleRequestOptions} parameter will take
       * precedence over the {@link RequestOptions} values provided at the time of the
       * {@link GoogleAIFileManager} initialization.
       */
      async listFiles(listParams, requestOptions = {}) {
        const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        const url = new FilesRequestUrl(RpcTask.LIST, this.apiKey, filesRequestOptions);
        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {
          url.appendParam("pageSize", listParams.pageSize.toString());
        }
        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {
          url.appendParam("pageToken", listParams.pageToken);
        }
        const uploadHeaders = getHeaders(url);
        const response = await makeServerRequest(url, uploadHeaders);
        return response.json();
      }
      /**
       * Get metadata for file with given ID.
       *
       * Any fields set in the optional {@link SingleRequestOptions} parameter will take
       * precedence over the {@link RequestOptions} values provided at the time of the
       * {@link GoogleAIFileManager} initialization.
       */
      async getFile(fileId, requestOptions = {}) {
        const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
        const url = new FilesRequestUrl(RpcTask.GET, this.apiKey, filesRequestOptions);
        url.appendPath(parseFileId(fileId));
        const uploadHeaders = getHeaders(url);
        const response = await makeServerRequest(url, uploadHeaders);
        return response.json();
      }
      /**
       * Delete file with given ID.
       */
      async deleteFile(fileId) {
        const url = new FilesRequestUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);
        url.appendPath(parseFileId(fileId));
        const uploadHeaders = getHeaders(url);
        await makeServerRequest(url, uploadHeaders);
      }
    };
    function parseFileId(fileId) {
      if (fileId.startsWith("files/")) {
        return fileId.split("files/")[1];
      }
      if (!fileId) {
        throw new GoogleGenerativeAIError(`Invalid fileId ${fileId}. Must be in the format "files/filename" or "filename"`);
      }
      return fileId;
    }
    function generateBoundary() {
      let str = "";
      for (let i = 0; i < 2; i++) {
        str = str + Math.random().toString().slice(2);
      }
      return str;
    }
    function getUploadMetadata(inputMetadata) {
      if (!inputMetadata.mimeType) {
        throw new GoogleGenerativeAIRequestInputError("Must provide a mimeType.");
      }
      const uploadMetadata = {
        mimeType: inputMetadata.mimeType,
        displayName: inputMetadata.displayName
      };
      if (inputMetadata.name) {
        uploadMetadata.name = inputMetadata.name.includes("/") ? inputMetadata.name : `files/${inputMetadata.name}`;
      }
      return uploadMetadata;
    }
    function formatSystemInstruction(input) {
      if (input == null) {
        return void 0;
      } else if (typeof input === "string") {
        return { role: "system", parts: [{ text: input }] };
      } else if (input.text) {
        return { role: "system", parts: [input] };
      } else if (input.parts) {
        if (!input.role) {
          return { role: "system", parts: input.parts };
        } else {
          return input;
        }
      }
    }
    var GoogleAICacheManager = class {
      constructor(apiKey2, _requestOptions) {
        this.apiKey = apiKey2;
        this._requestOptions = _requestOptions;
      }
      /**
       * Upload a new content cache
       */
      async create(createOptions) {
        const newCachedContent = Object.assign({}, createOptions);
        if (createOptions.ttlSeconds) {
          if (createOptions.expireTime) {
            throw new GoogleGenerativeAIRequestInputError("You cannot specify both `ttlSeconds` and `expireTime` when creating a content cache. You must choose one.");
          }
          newCachedContent.ttl = createOptions.ttlSeconds.toString() + "s";
          delete newCachedContent.ttlSeconds;
        }
        if (createOptions.systemInstruction) {
          newCachedContent.systemInstruction = formatSystemInstruction(createOptions.systemInstruction);
        }
        if (!newCachedContent.model) {
          throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
        }
        if (!newCachedContent.model.includes("/")) {
          newCachedContent.model = `models/${newCachedContent.model}`;
        }
        const url = new CachedContentUrl(RpcTask.CREATE, this.apiKey, this._requestOptions);
        const headers = getHeaders(url);
        const response = await makeServerRequest(url, headers, JSON.stringify(newCachedContent));
        return response.json();
      }
      /**
       * List all uploaded content caches
       */
      async list(listParams) {
        const url = new CachedContentUrl(RpcTask.LIST, this.apiKey, this._requestOptions);
        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {
          url.appendParam("pageSize", listParams.pageSize.toString());
        }
        if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {
          url.appendParam("pageToken", listParams.pageToken);
        }
        const headers = getHeaders(url);
        const response = await makeServerRequest(url, headers);
        return response.json();
      }
      /**
       * Get a content cache
       */
      async get(name) {
        const url = new CachedContentUrl(RpcTask.GET, this.apiKey, this._requestOptions);
        url.appendPath(parseCacheName(name));
        const headers = getHeaders(url);
        const response = await makeServerRequest(url, headers);
        return response.json();
      }
      /**
       * Update an existing content cache
       */
      async update(name, updateParams) {
        const url = new CachedContentUrl(RpcTask.UPDATE, this.apiKey, this._requestOptions);
        url.appendPath(parseCacheName(name));
        const headers = getHeaders(url);
        const formattedCachedContent = Object.assign({}, updateParams.cachedContent);
        if (updateParams.cachedContent.ttlSeconds) {
          formattedCachedContent.ttl = updateParams.cachedContent.ttlSeconds.toString() + "s";
          delete formattedCachedContent.ttlSeconds;
        }
        if (updateParams.updateMask) {
          url.appendParam("update_mask", updateParams.updateMask.map((prop) => camelToSnake(prop)).join(","));
        }
        const response = await makeServerRequest(url, headers, JSON.stringify(formattedCachedContent));
        return response.json();
      }
      /**
       * Delete content cache with given name
       */
      async delete(name) {
        const url = new CachedContentUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);
        url.appendPath(parseCacheName(name));
        const headers = getHeaders(url);
        await makeServerRequest(url, headers);
      }
    };
    function parseCacheName(name) {
      if (name.startsWith("cachedContents/")) {
        return name.split("cachedContents/")[1];
      }
      if (!name) {
        throw new GoogleGenerativeAIError(`Invalid name ${name}. Must be in the format "cachedContents/name" or "name"`);
      }
      return name;
    }
    function camelToSnake(str) {
      return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
    }
    exports.FileState = void 0;
    (function(FileState) {
      FileState["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
      FileState["PROCESSING"] = "PROCESSING";
      FileState["ACTIVE"] = "ACTIVE";
      FileState["FAILED"] = "FAILED";
    })(exports.FileState || (exports.FileState = {}));
    exports.SchemaType = void 0;
    (function(SchemaType) {
      SchemaType["STRING"] = "string";
      SchemaType["NUMBER"] = "number";
      SchemaType["INTEGER"] = "integer";
      SchemaType["BOOLEAN"] = "boolean";
      SchemaType["ARRAY"] = "array";
      SchemaType["OBJECT"] = "object";
    })(exports.SchemaType || (exports.SchemaType = {}));
    exports.ExecutableCodeLanguage = void 0;
    (function(ExecutableCodeLanguage) {
      ExecutableCodeLanguage["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
      ExecutableCodeLanguage["PYTHON"] = "python";
    })(exports.ExecutableCodeLanguage || (exports.ExecutableCodeLanguage = {}));
    exports.Outcome = void 0;
    (function(Outcome) {
      Outcome["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
      Outcome["OUTCOME_OK"] = "outcome_ok";
      Outcome["OUTCOME_FAILED"] = "outcome_failed";
      Outcome["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
    })(exports.Outcome || (exports.Outcome = {}));
    var HarmCategory;
    (function(HarmCategory2) {
      HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
      HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
      HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
      HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
      HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
      HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
    })(HarmCategory || (HarmCategory = {}));
    var HarmBlockThreshold;
    (function(HarmBlockThreshold2) {
      HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
      HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
      HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
      HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
    })(HarmBlockThreshold || (HarmBlockThreshold = {}));
    var HarmProbability;
    (function(HarmProbability2) {
      HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
      HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
      HarmProbability2["LOW"] = "LOW";
      HarmProbability2["MEDIUM"] = "MEDIUM";
      HarmProbability2["HIGH"] = "HIGH";
    })(HarmProbability || (HarmProbability = {}));
    var BlockReason;
    (function(BlockReason2) {
      BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
      BlockReason2["SAFETY"] = "SAFETY";
      BlockReason2["OTHER"] = "OTHER";
    })(BlockReason || (BlockReason = {}));
    var FinishReason;
    (function(FinishReason2) {
      FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
      FinishReason2["STOP"] = "STOP";
      FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
      FinishReason2["SAFETY"] = "SAFETY";
      FinishReason2["RECITATION"] = "RECITATION";
      FinishReason2["LANGUAGE"] = "LANGUAGE";
      FinishReason2["BLOCKLIST"] = "BLOCKLIST";
      FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
      FinishReason2["SPII"] = "SPII";
      FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
      FinishReason2["OTHER"] = "OTHER";
    })(FinishReason || (FinishReason = {}));
    var TaskType;
    (function(TaskType2) {
      TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
      TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
      TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
      TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
      TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
      TaskType2["CLUSTERING"] = "CLUSTERING";
    })(TaskType || (TaskType = {}));
    exports.FunctionCallingMode = void 0;
    (function(FunctionCallingMode) {
      FunctionCallingMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      FunctionCallingMode["AUTO"] = "AUTO";
      FunctionCallingMode["ANY"] = "ANY";
      FunctionCallingMode["NONE"] = "NONE";
    })(exports.FunctionCallingMode || (exports.FunctionCallingMode = {}));
    var DynamicRetrievalMode;
    (function(DynamicRetrievalMode2) {
      DynamicRetrievalMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
      DynamicRetrievalMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
    })(DynamicRetrievalMode || (DynamicRetrievalMode = {}));
    exports.GoogleAICacheManager = GoogleAICacheManager;
    exports.GoogleAIFileManager = GoogleAIFileManager;
  }
});

// node_modules/@genkit-ai/googleai/lib/context-caching/constants.js
var require_constants = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/context-caching/constants.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var constants_exports = {};
    __export2(constants_exports, {
      CONTEXT_CACHE_SUPPORTED_MODELS: () => CONTEXT_CACHE_SUPPORTED_MODELS,
      DEFAULT_TTL: () => DEFAULT_TTL,
      INVALID_ARGUMENT_MESSAGES: () => INVALID_ARGUMENT_MESSAGES
    });
    module.exports = __toCommonJS(constants_exports);
    var CONTEXT_CACHE_SUPPORTED_MODELS = [
      "gemini-1.5-flash-001",
      "gemini-1.5-pro-001"
    ];
    var INVALID_ARGUMENT_MESSAGES = {
      modelVersion: `Model version is required for context caching, supported only in ${CONTEXT_CACHE_SUPPORTED_MODELS.join(",")} models.`,
      tools: "Context caching cannot be used simultaneously with tools.",
      codeExecution: "Context caching cannot be used simultaneously with code execution."
    };
    var DEFAULT_TTL = 300;
  }
});

// node_modules/@genkit-ai/googleai/lib/context-caching/types.js
var require_types2 = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/context-caching/types.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var types_exports = {};
    __export2(types_exports, {
      cacheConfigDetailsSchema: () => cacheConfigDetailsSchema,
      cacheConfigSchema: () => cacheConfigSchema
    });
    module.exports = __toCommonJS(types_exports);
    var import_genkit2 = require_lib();
    var cacheConfigSchema = import_genkit2.z.union([
      import_genkit2.z.boolean(),
      import_genkit2.z.object({ ttlSeconds: import_genkit2.z.number().optional() }).passthrough()
    ]);
    var cacheConfigDetailsSchema = import_genkit2.z.object({
      cacheConfig: cacheConfigSchema,
      endOfCachedContents: import_genkit2.z.number()
    });
  }
});

// node_modules/@genkit-ai/googleai/lib/context-caching/utils.js
var require_utils2 = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/context-caching/utils.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var utils_exports = {};
    __export2(utils_exports, {
      calculateTTL: () => calculateTTL,
      extractCacheConfig: () => extractCacheConfig,
      findLastIndex: () => findLastIndex,
      generateCacheKey: () => generateCacheKey,
      getContentForCache: () => getContentForCache,
      lookupContextCache: () => lookupContextCache,
      validateContextCacheRequest: () => validateContextCacheRequest
    });
    module.exports = __toCommonJS(utils_exports);
    var import_crypto2 = __toESM2(require_crypto());
    var import_genkit2 = require_lib();
    var import_constants = require_constants();
    var import_types = require_types2();
    function generateCacheKey(request) {
      return import_crypto2.default.createHash("sha256").update(JSON.stringify(request)).digest("hex");
    }
    function getContentForCache(request, chatRequest, modelVersion, cacheConfigDetails) {
      var _a;
      if (!modelVersion) {
        throw new Error("No model version provided for context caching");
      }
      if (!((_a = chatRequest.history) == null ? void 0 : _a.length)) {
        throw new Error("No history provided for context caching");
      }
      validateHistoryLength(request, chatRequest);
      const { endOfCachedContents, cacheConfig } = cacheConfigDetails;
      const cachedContent = {
        model: modelVersion,
        contents: chatRequest.history.slice(0, endOfCachedContents + 1)
      };
      chatRequest.history = chatRequest.history.slice(endOfCachedContents + 1);
      return { cachedContent, chatRequest, cacheConfig };
    }
    function validateHistoryLength(request, chatRequest) {
      var _a;
      if (((_a = chatRequest.history) == null ? void 0 : _a.length) !== request.messages.length - 1) {
        throw new import_genkit2.GenkitError({
          status: "INTERNAL",
          message: "Genkit request history and Gemini chat request history length do not match"
        });
      }
    }
    async function lookupContextCache(cacheManager, cacheKey, maxPages = 100, pageSize = 100) {
      let currentPage = 0;
      let pageToken;
      try {
        while (currentPage < maxPages) {
          const { cachedContents, nextPageToken } = await cacheManager.list({
            pageSize,
            pageToken
          });
          const found = cachedContents == null ? void 0 : cachedContents.find(
            (content) => content.displayName === cacheKey
          );
          if (found) return found;
          if (!nextPageToken) break;
          pageToken = nextPageToken;
          currentPage++;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown Network Error";
        throw new import_genkit2.GenkitError({
          status: "INTERNAL",
          message: `Error looking up context cache: ${message}`
        });
      }
      return null;
    }
    var extractCacheConfig = (request) => {
      var _a;
      const endOfCachedContents = findLastIndex(
        request.messages,
        (message) => {
          var _a2;
          return !!((_a2 = message.metadata) == null ? void 0 : _a2.cache);
        }
      );
      return endOfCachedContents === -1 ? null : {
        endOfCachedContents,
        cacheConfig: import_types.cacheConfigSchema.parse(
          (_a = request.messages[endOfCachedContents].metadata) == null ? void 0 : _a.cache
        )
      };
    };
    function validateContextCacheRequest(request, modelVersion) {
      var _a, _b;
      if (!modelVersion || !import_constants.CONTEXT_CACHE_SUPPORTED_MODELS.includes(modelVersion)) {
        throw new import_genkit2.GenkitError({
          status: "INVALID_ARGUMENT",
          message: import_constants.INVALID_ARGUMENT_MESSAGES.modelVersion
        });
      }
      if ((_a = request.tools) == null ? void 0 : _a.length)
        throw new import_genkit2.GenkitError({
          status: "INVALID_ARGUMENT",
          message: import_constants.INVALID_ARGUMENT_MESSAGES.tools
        });
      if ((_b = request.config) == null ? void 0 : _b.codeExecution)
        throw new import_genkit2.GenkitError({
          status: "INVALID_ARGUMENT",
          message: import_constants.INVALID_ARGUMENT_MESSAGES.codeExecution
        });
      return true;
    }
    function findLastIndex(array, callback) {
      for (let i = array.length - 1; i >= 0; i--) {
        if (callback(array[i], i, array)) return i;
      }
      return -1;
    }
    function calculateTTL(cacheConfig) {
      if (cacheConfig.cacheConfig === true) {
        return import_constants.DEFAULT_TTL;
      }
      if (cacheConfig.cacheConfig === false) {
        return 0;
      }
      return cacheConfig.cacheConfig.ttlSeconds || import_constants.DEFAULT_TTL;
    }
  }
});

// node_modules/@genkit-ai/googleai/lib/context-caching/index.js
var require_context_caching = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/context-caching/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var context_caching_exports = {};
    __export2(context_caching_exports, {
      handleCacheIfNeeded: () => handleCacheIfNeeded,
      handleContextCache: () => handleContextCache
    });
    module.exports = __toCommonJS(context_caching_exports);
    var import_server = require_server();
    var import_genkit2 = require_lib();
    var import_logging6 = require_logging2();
    var import_utils = require_utils2();
    async function handleContextCache(apiKey2, request, chatRequest, modelVersion, cacheConfigDetails) {
      const cacheManager = new import_server.GoogleAICacheManager(apiKey2);
      const { cachedContent, chatRequest: newChatRequest } = (0, import_utils.getContentForCache)(
        request,
        chatRequest,
        modelVersion,
        cacheConfigDetails
      );
      cachedContent.model = modelVersion;
      const cacheKey = (0, import_utils.generateCacheKey)(cachedContent);
      cachedContent.displayName = cacheKey;
      let cache = await (0, import_utils.lookupContextCache)(cacheManager, cacheKey);
      import_logging6.logger.debug(`Cache hit: ${cache ? "true" : "false"}`);
      if (!cache) {
        try {
          import_logging6.logger.debug("No cache found, creating one.");
          const createParams = {
            ...cachedContent,
            ttlSeconds: (0, import_utils.calculateTTL)(cacheConfigDetails)
          };
          cache = await cacheManager.create(createParams);
          import_logging6.logger.debug(`Created new cache entry with key: ${cacheKey}`);
        } catch (cacheError) {
          import_logging6.logger.error(
            `Failed to create cache with key ${cacheKey}: ${cacheError}`
          );
          throw new import_genkit2.GenkitError({
            status: "INTERNAL",
            message: `Failed to create cache: ${cacheError}`
          });
        }
      }
      if (!cache) {
        throw new import_genkit2.GenkitError({
          status: "INTERNAL",
          message: "Failed to use context cache feature"
        });
      }
      return { cache, newChatRequest };
    }
    async function handleCacheIfNeeded(apiKey2, request, chatRequest, modelVersion, cacheConfigDetails) {
      if (!cacheConfigDetails || !(0, import_utils.validateContextCacheRequest)(request, modelVersion)) {
        return { chatRequest, cache: null };
      }
      const { cache, newChatRequest } = await handleContextCache(
        apiKey2,
        request,
        chatRequest,
        modelVersion,
        cacheConfigDetails
      );
      return { chatRequest: newChatRequest, cache };
    }
  }
});

// node_modules/@genkit-ai/googleai/lib/gemini.js
var require_gemini = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/gemini.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var gemini_exports = {};
    __export2(gemini_exports, {
      GENERIC_GEMINI_MODEL: () => GENERIC_GEMINI_MODEL,
      GeminiConfigSchema: () => GeminiConfigSchema2,
      GeminiGemmaConfigSchema: () => GeminiGemmaConfigSchema,
      GeminiTtsConfigSchema: () => GeminiTtsConfigSchema,
      SUPPORTED_GEMINI_MODELS: () => SUPPORTED_GEMINI_MODELS2,
      aggregateResponses: () => aggregateResponses,
      cleanSchema: () => cleanSchema,
      defineGoogleAIModel: () => defineGoogleAIModel2,
      fromGeminiCandidate: () => fromGeminiCandidate,
      gemini: () => gemini2,
      gemini10Pro: () => gemini10Pro2,
      gemini15Flash: () => gemini15Flash2,
      gemini15Flash8b: () => gemini15Flash8b2,
      gemini15Pro: () => gemini15Pro2,
      gemini20Flash: () => gemini20Flash2,
      gemini20FlashExp: () => gemini20FlashExp2,
      gemini20FlashLite: () => gemini20FlashLite2,
      gemini20ProExp0205: () => gemini20ProExp02052,
      gemini25Flash: () => gemini25Flash,
      gemini25FlashLite: () => gemini25FlashLite2,
      gemini25FlashPreview0417: () => gemini25FlashPreview04172,
      gemini25FlashPreviewTts: () => gemini25FlashPreviewTts,
      gemini25Pro: () => gemini25Pro,
      gemini25ProExp0325: () => gemini25ProExp03252,
      gemini25ProPreview0325: () => gemini25ProPreview03252,
      gemini25ProPreviewTts: () => gemini25ProPreviewTts,
      gemma312bit: () => gemma312bit,
      gemma31bit: () => gemma31bit,
      gemma327bit: () => gemma327bit,
      gemma34bit: () => gemma34bit,
      gemma3ne4bit: () => gemma3ne4bit,
      toGeminiMessage: () => toGeminiMessage,
      toGeminiSystemInstruction: () => toGeminiSystemInstruction,
      toGeminiTool: () => toGeminiTool
    });
    module.exports = __toCommonJS(gemini_exports);
    var import_generative_ai = require_dist2();
    var import_genkit2 = require_lib();
    var import_model4 = require_model2();
    var import_middleware2 = require_middleware2();
    var import_tracing2 = require_tracing();
    var import_common2 = require_common2();
    var import_context_caching = require_context_caching();
    var import_utils = require_utils2();
    var SafetySettingsSchema = import_genkit2.z.object({
      category: import_genkit2.z.enum([
        "HARM_CATEGORY_UNSPECIFIED",
        "HARM_CATEGORY_HATE_SPEECH",
        "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        "HARM_CATEGORY_HARASSMENT",
        "HARM_CATEGORY_DANGEROUS_CONTENT",
        "HARM_CATEGORY_CIVIC_INTEGRITY"
      ]),
      threshold: import_genkit2.z.enum([
        "BLOCK_LOW_AND_ABOVE",
        "BLOCK_MEDIUM_AND_ABOVE",
        "BLOCK_ONLY_HIGH",
        "BLOCK_NONE"
      ])
    });
    var VoiceConfigSchema = import_genkit2.z.object({
      prebuiltVoiceConfig: import_genkit2.z.object({
        // TODO: Make this an array of objects so we can also specify the description
        // for each voiceName.
        voiceName: import_genkit2.z.union([
          import_genkit2.z.enum([
            "Zephyr",
            "Puck",
            "Charon",
            "Kore",
            "Fenrir",
            "Leda",
            "Orus",
            "Aoede",
            "Callirrhoe",
            "Autonoe",
            "Enceladus",
            "Iapetus",
            "Umbriel",
            "Algieba",
            "Despina",
            "Erinome",
            "Algenib",
            "Rasalgethi",
            "Laomedeia",
            "Achernar",
            "Alnilam",
            "Schedar",
            "Gacrux",
            "Pulcherrima",
            "Achird",
            "Zubenelgenubi",
            "Vindemiatrix",
            "Sadachbia",
            "Sadaltager",
            "Sulafat"
          ]),
          // To allow any new string values
          import_genkit2.z.string()
        ]).describe("Name of the preset voice to use").optional()
      }).describe("Configuration for the prebuilt speaker to use").passthrough().optional()
    }).describe("Configuration for the voice to use").passthrough();
    var GeminiConfigSchema2 = import_model4.GenerationCommonConfigSchema.extend({
      temperature: import_genkit2.z.number().min(0).max(2).describe(
        import_model4.GenerationCommonConfigDescriptions.temperature + " The default value is 1.0."
      ).optional(),
      topP: import_genkit2.z.number().min(0).max(1).describe(
        import_model4.GenerationCommonConfigDescriptions.topP + " The default value is 0.95."
      ).optional(),
      apiKey: import_genkit2.z.string().describe("Overrides the plugin-configured API key, if specified.").optional(),
      safetySettings: import_genkit2.z.array(SafetySettingsSchema).describe(
        "Adjust how likely you are to see responses that could be harmful. Content is blocked based on the probability that it is harmful."
      ).optional(),
      codeExecution: import_genkit2.z.union([import_genkit2.z.boolean(), import_genkit2.z.object({}).strict()]).describe("Enables the model to generate and run code.").optional(),
      contextCache: import_genkit2.z.boolean().describe(
        "Context caching allows you to save and reuse precomputed input tokens that you wish to use repeatedly."
      ).optional(),
      functionCallingConfig: import_genkit2.z.object({
        mode: import_genkit2.z.enum(["MODE_UNSPECIFIED", "AUTO", "ANY", "NONE"]).optional(),
        allowedFunctionNames: import_genkit2.z.array(import_genkit2.z.string()).optional()
      }).describe(
        "Controls how the model uses the provided tools (function declarations). With AUTO (Default) mode, the model decides whether to generate a natural language response or suggest a function call based on the prompt and context. With ANY, the model is constrained to always predict a function call and guarantee function schema adherence. With NONE, the model is prohibited from making function calls."
      ).optional(),
      responseModalities: import_genkit2.z.array(import_genkit2.z.enum(["TEXT", "IMAGE", "AUDIO"])).describe(
        "The modalities to be used in response. Only supported for 'gemini-2.0-flash-exp' model at present."
      ).optional(),
      googleSearchRetrieval: import_genkit2.z.union([import_genkit2.z.boolean(), import_genkit2.z.object({}).passthrough()]).describe(
        "Retrieve public web data for grounding, powered by Google Search."
      ).optional(),
      thinkingConfig: import_genkit2.z.object({
        includeThoughts: import_genkit2.z.boolean().describe(
          "Indicates whether to include thoughts in the response.If true, thoughts are returned only when available."
        ).optional(),
        thinkingBudget: import_genkit2.z.number().min(0).max(24576).describe(
          "The thinking budget parameter gives the model guidance on the number of thinking tokens it can use when generating a response. A greater number of tokens is typically associated with more detailed thinking, which is needed for solving more complex tasks. Setting the thinking budget to 0 disables thinking."
        ).optional()
      }).optional()
    }).passthrough();
    var GeminiGemmaConfigSchema = GeminiConfigSchema2.extend({
      temperature: import_genkit2.z.number().min(0).max(1).describe(
        import_model4.GenerationCommonConfigDescriptions.temperature + " The default value is 1.0."
      ).optional()
    }).passthrough();
    var GeminiTtsConfigSchema = GeminiConfigSchema2.extend({
      speechConfig: import_genkit2.z.object({
        voiceConfig: VoiceConfigSchema.optional(),
        multiSpeakerVoiceConfig: import_genkit2.z.object({
          speakerVoiceConfigs: import_genkit2.z.array(
            import_genkit2.z.object({
              speaker: import_genkit2.z.string().describe("Name of the speaker to use"),
              voiceConfig: VoiceConfigSchema
            }).describe(
              "Configuration for a single speaker in a multi speaker setup"
            ).passthrough()
          ).describe("Configuration for all the enabled speaker voices")
        }).describe("Configuration for multi-speaker setup").passthrough().optional()
      }).describe("Speech generation config").passthrough().optional()
    }).passthrough();
    var gemini10Pro2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-1.0-pro",
      info: {
        label: "Google AI - Gemini Pro",
        versions: ["gemini-pro", "gemini-1.0-pro-latest", "gemini-1.0-pro-001"],
        supports: {
          multiturn: true,
          media: false,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini15Pro2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-1.5-pro",
      info: {
        label: "Google AI - Gemini 1.5 Pro",
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        },
        versions: [
          "gemini-1.5-pro-latest",
          "gemini-1.5-pro-001",
          "gemini-1.5-pro-002"
        ]
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini15Flash2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-1.5-flash",
      info: {
        label: "Google AI - Gemini 1.5 Flash",
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools",
          // @ts-ignore
          contextCache: true
        },
        versions: [
          "gemini-1.5-flash-latest",
          "gemini-1.5-flash-001",
          "gemini-1.5-flash-002"
        ]
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini15Flash8b2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-1.5-flash-8b",
      info: {
        label: "Google AI - Gemini 1.5 Flash",
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        },
        versions: ["gemini-1.5-flash-8b-latest", "gemini-1.5-flash-8b-001"]
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini20Flash2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.0-flash",
      info: {
        label: "Google AI - Gemini 2.0 Flash",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini20FlashExp2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.0-flash-exp",
      info: {
        label: "Google AI - Gemini 2.0 Flash (Experimental)",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini20FlashLite2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.0-flash-lite",
      info: {
        label: "Google AI - Gemini 2.0 Flash Lite",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini20ProExp02052 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.0-pro-exp-02-05",
      info: {
        label: "Google AI - Gemini 2.0 Pro Exp 02-05",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini25FlashPreview04172 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-flash-preview-04-17",
      info: {
        label: "Google AI - Gemini 2.5 Flash Preview 04-17",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini25FlashPreviewTts = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-flash-preview-tts",
      info: {
        label: "Google AI - Gemini 2.5 Flash Preview TTS",
        versions: [],
        supports: {
          multiturn: false,
          media: false,
          tools: false,
          toolChoice: false,
          systemRole: false,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiTtsConfigSchema
    });
    var gemini25ProExp03252 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-pro-exp-03-25",
      info: {
        label: "Google AI - Gemini 2.5 Pro Exp 03-25",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini25ProPreview03252 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-pro-preview-03-25",
      info: {
        label: "Google AI - Gemini 2.5 Pro Preview 03-25",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini25ProPreviewTts = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-pro-preview-tts",
      info: {
        label: "Google AI - Gemini 2.5 Pro Preview TTS",
        versions: [],
        supports: {
          multiturn: false,
          media: false,
          tools: false,
          toolChoice: false,
          systemRole: false,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiTtsConfigSchema
    });
    var gemini25Pro = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-pro",
      info: {
        label: "Google AI - Gemini 2.5 Pro",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini25Flash = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-flash",
      info: {
        label: "Google AI - Gemini 2.5 Flash",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemini25FlashLite2 = (0, import_model4.modelRef)({
      name: "googleai/gemini-2.5-flash-lite",
      info: {
        label: "Google AI - Gemini 2.5 Flash Lite",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiConfigSchema2
    });
    var gemma312bit = (0, import_model4.modelRef)({
      name: "googleai/gemma-3-12b-it",
      info: {
        label: "Google AI - Gemma 3 12B",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiGemmaConfigSchema
    });
    var gemma31bit = (0, import_model4.modelRef)({
      name: "googleai/gemma-3-1b-it",
      info: {
        label: "Google AI - Gemma 3 1B",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiGemmaConfigSchema
    });
    var gemma327bit = (0, import_model4.modelRef)({
      name: "googleai/gemma-3-27b-it",
      info: {
        label: "Google AI - Gemma 3 27B",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiGemmaConfigSchema
    });
    var gemma34bit = (0, import_model4.modelRef)({
      name: "googleai/gemma-3-4b-it",
      info: {
        label: "Google AI - Gemma 3 4B",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiGemmaConfigSchema
    });
    var gemma3ne4bit = (0, import_model4.modelRef)({
      name: "googleai/gemma-3n-e4b-it",
      info: {
        label: "Google AI - Gemma 3n E4B",
        versions: [],
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      },
      configSchema: GeminiGemmaConfigSchema
    });
    var SUPPORTED_GEMINI_MODELS2 = {
      "gemini-1.5-pro": gemini15Pro2,
      "gemini-1.5-flash": gemini15Flash2,
      "gemini-1.5-flash-8b": gemini15Flash8b2,
      "gemini-2.0-pro-exp-02-05": gemini20ProExp02052,
      "gemini-2.0-flash": gemini20Flash2,
      "gemini-2.0-flash-lite": gemini20FlashLite2,
      "gemini-2.0-flash-exp": gemini20FlashExp2,
      "gemini-2.5-pro-exp-03-25": gemini25ProExp03252,
      "gemini-2.5-pro-preview-03-25": gemini25ProPreview03252,
      "gemini-2.5-pro-preview-tts": gemini25ProPreviewTts,
      "gemini-2.5-flash-preview-04-17": gemini25FlashPreview04172,
      "gemini-2.5-flash-preview-tts": gemini25FlashPreviewTts,
      "gemini-2.5-flash": gemini25Flash,
      "gemini-2.5-flash-lite": gemini25FlashLite2,
      "gemini-2.5-pro": gemini25Pro,
      "gemma-3-12b-it": gemma312bit,
      "gemma-3-1b-it": gemma31bit,
      "gemma-3-27b-it": gemma327bit,
      "gemma-3-4b-it": gemma34bit,
      "gemma-3n-e4b-it": gemma3ne4bit
    };
    var GENERIC_GEMINI_MODEL = (0, import_model4.modelRef)({
      name: "googleai/gemini",
      configSchema: GeminiConfigSchema2,
      info: {
        label: "Google Gemini",
        supports: {
          multiturn: true,
          media: true,
          tools: true,
          toolChoice: true,
          systemRole: true,
          constrained: "no-tools"
        }
      }
    });
    function longestMatchingPrefix(version2, potentialMatches) {
      return potentialMatches.filter((p) => version2.startsWith(p)).reduce(
        (longest, current) => current.length > longest.length ? current : longest,
        ""
      );
    }
    function gemini2(version2, options = {}) {
      var _a;
      const nearestModel = nearestGeminiModelRef(version2);
      return (0, import_model4.modelRef)({
        name: `googleai/${version2}`,
        config: options,
        configSchema: GeminiConfigSchema2,
        info: {
          ...nearestModel.info,
          // If exact suffix match for a known model, use its label, otherwise create a new label
          label: nearestModel.name.endsWith(version2) ? (_a = nearestModel.info) == null ? void 0 : _a.label : `Google AI - ${version2}`
        }
      });
    }
    function nearestGeminiModelRef(version2, options = {}) {
      const matchingKey = longestMatchingPrefix(
        version2,
        Object.keys(SUPPORTED_GEMINI_MODELS2)
      );
      if (matchingKey) {
        return SUPPORTED_GEMINI_MODELS2[matchingKey].withConfig({
          ...options,
          version: version2
        });
      }
      return GENERIC_GEMINI_MODEL.withConfig({ ...options, version: version2 });
    }
    function toGeminiRole(role, model2) {
      var _a, _b;
      switch (role) {
        case "user":
          return "user";
        case "model":
          return "model";
        case "system":
          if ((_b = (_a = model2 == null ? void 0 : model2.info) == null ? void 0 : _a.supports) == null ? void 0 : _b.systemRole) {
            throw new Error(
              "system role is only supported for a single message in the first position"
            );
          } else {
            throw new Error("system role is not supported");
          }
        case "tool":
          return "function";
        default:
          return "user";
      }
    }
    function convertSchemaProperty(property) {
      if (!property || !property.type) {
        return void 0;
      }
      const baseSchema = {};
      if (property.description) {
        baseSchema.description = property.description;
      }
      if (property.enum) {
        baseSchema.type = import_generative_ai.SchemaType.STRING;
        baseSchema.enum = property.enum;
      }
      if (property.nullable) {
        baseSchema.nullable = property.nullable;
      }
      let propertyType;
      if (Array.isArray(property.type)) {
        const types = property.type;
        if (types.includes("null")) {
          baseSchema.nullable = true;
        }
        propertyType = types.find((t) => t !== "null");
      } else {
        propertyType = property.type;
      }
      if (propertyType === "object") {
        const nestedProperties = {};
        Object.keys(property.properties ?? {}).forEach((key) => {
          nestedProperties[key] = convertSchemaProperty(property.properties[key]);
        });
        return {
          ...baseSchema,
          type: import_generative_ai.SchemaType.OBJECT,
          properties: nestedProperties,
          required: property.required
        };
      } else if (propertyType === "array") {
        return {
          ...baseSchema,
          type: import_generative_ai.SchemaType.ARRAY,
          items: convertSchemaProperty(property.items)
        };
      } else {
        const schemaType = import_generative_ai.SchemaType[propertyType.toUpperCase()];
        if (!schemaType) {
          throw new import_genkit2.GenkitError({
            status: "INVALID_ARGUMENT",
            message: `Unsupported property type ${propertyType.toUpperCase()}`
          });
        }
        return {
          ...baseSchema,
          type: schemaType
        };
      }
    }
    function toGeminiTool(tool) {
      const declaration = {
        name: tool.name.replace(/\//g, "__"),
        // Gemini throws on '/' in tool name
        description: tool.description,
        parameters: convertSchemaProperty(tool.inputSchema)
      };
      return declaration;
    }
    function toInlineData(part) {
      const dataUrl = part.media.url;
      const b64Data = dataUrl.substring(dataUrl.indexOf(",") + 1);
      const contentType = part.media.contentType || dataUrl.substring(dataUrl.indexOf(":") + 1, dataUrl.indexOf(";"));
      return { inlineData: { mimeType: contentType, data: b64Data } };
    }
    function toFileData(part) {
      if (!part.media.contentType)
        throw new Error(
          "Must supply a `contentType` when sending File URIs to Gemini."
        );
      return {
        fileData: { mimeType: part.media.contentType, fileUri: part.media.url }
      };
    }
    function fromInlineData(inlinePart) {
      if (!inlinePart.inlineData || !inlinePart.inlineData.hasOwnProperty("mimeType") || !inlinePart.inlineData.hasOwnProperty("data")) {
        throw new Error("Invalid InlineDataPart: missing required properties");
      }
      const { mimeType, data } = inlinePart.inlineData;
      const dataUrl = `data:${mimeType};base64,${data}`;
      return {
        media: {
          url: dataUrl,
          contentType: mimeType
        }
      };
    }
    function toFunctionCall(part) {
      var _a;
      if (!((_a = part == null ? void 0 : part.toolRequest) == null ? void 0 : _a.input)) {
        throw Error("Invalid ToolRequestPart: input was missing.");
      }
      return {
        functionCall: {
          name: part.toolRequest.name,
          args: part.toolRequest.input
        }
      };
    }
    function fromFunctionCall(part, ref) {
      if (!part.functionCall) {
        throw Error("Invalid FunctionCallPart");
      }
      return {
        toolRequest: {
          name: part.functionCall.name,
          input: part.functionCall.args,
          ref
        }
      };
    }
    function toFunctionResponse(part) {
      var _a;
      if (!((_a = part == null ? void 0 : part.toolResponse) == null ? void 0 : _a.output)) {
        throw Error("Invalid ToolResponsePart: output was missing.");
      }
      return {
        functionResponse: {
          name: part.toolResponse.name,
          response: {
            name: part.toolResponse.name,
            content: part.toolResponse.output
          }
        }
      };
    }
    function fromFunctionResponse(part) {
      if (!part.functionResponse) {
        throw new Error("Invalid FunctionResponsePart.");
      }
      return {
        toolResponse: {
          name: part.functionResponse.name.replace(/__/g, "/"),
          // restore slashes
          output: part.functionResponse.response
        }
      };
    }
    function fromExecutableCode(part) {
      if (!part.executableCode) {
        throw new Error("Invalid GeminiPart: missing executableCode");
      }
      return {
        custom: {
          executableCode: {
            language: part.executableCode.language,
            code: part.executableCode.code
          }
        }
      };
    }
    function fromCodeExecutionResult(part) {
      if (!part.codeExecutionResult) {
        throw new Error("Invalid GeminiPart: missing codeExecutionResult");
      }
      return {
        custom: {
          codeExecutionResult: {
            outcome: part.codeExecutionResult.outcome,
            output: part.codeExecutionResult.output
          }
        }
      };
    }
    function fromThought(part) {
      return {
        reasoning: part.text || "",
        metadata: { thoughtSignature: part.thoughtSignature }
      };
    }
    function toCustomPart(part) {
      if (!part.custom) {
        throw new Error("Invalid GeminiPart: missing custom");
      }
      if (part.custom.codeExecutionResult) {
        return { codeExecutionResult: part.custom.codeExecutionResult };
      }
      if (part.custom.executableCode) {
        return { executableCode: part.custom.executableCode };
      }
      throw new Error("Unsupported Custom Part type");
    }
    function toThought(part) {
      var _a, _b;
      const outPart = { thought: true };
      if ((_a = part.metadata) == null ? void 0 : _a.thoughtSignature)
        outPart.thoughtSignature = part.metadata.thoughtSignature;
      if ((_b = part.reasoning) == null ? void 0 : _b.length) outPart.text = part.reasoning;
      return outPart;
    }
    function toGeminiPart(part) {
      if (part.text !== void 0) return { text: part.text || " " };
      if (part.media) {
        if (part.media.url.startsWith("data:")) return toInlineData(part);
        return toFileData(part);
      }
      if (part.toolRequest) return toFunctionCall(part);
      if (part.toolResponse) return toFunctionResponse(part);
      if (part.custom) return toCustomPart(part);
      if (typeof part.reasoning === "string") return toThought(part);
      throw new Error("Unsupported Part type" + JSON.stringify(part));
    }
    function fromGeminiPart(part, jsonMode, ref) {
      if ("thought" in part) return fromThought(part);
      if (typeof part.text === "string") return { text: part.text };
      if (part.inlineData) return fromInlineData(part);
      if (part.functionCall) return fromFunctionCall(part, ref);
      if (part.functionResponse) return fromFunctionResponse(part);
      if (part.executableCode) return fromExecutableCode(part);
      if (part.codeExecutionResult) return fromCodeExecutionResult(part);
      throw new Error("Unsupported GeminiPart type: " + JSON.stringify(part));
    }
    function toGeminiMessage(message, model2) {
      let sortedParts = message.content;
      if (message.role === "tool") {
        sortedParts = [...message.content].sort((a, b) => {
          var _a, _b;
          const aRef = (_a = a.toolResponse) == null ? void 0 : _a.ref;
          const bRef = (_b = b.toolResponse) == null ? void 0 : _b.ref;
          if (!aRef && !bRef) return 0;
          if (!aRef) return 1;
          if (!bRef) return -1;
          return Number.parseInt(aRef, 10) - Number.parseInt(bRef, 10);
        });
      }
      return {
        role: toGeminiRole(message.role, model2),
        parts: sortedParts.map(toGeminiPart)
      };
    }
    function toGeminiSystemInstruction(message) {
      return {
        role: "user",
        parts: message.content.map(toGeminiPart)
      };
    }
    function fromGeminiFinishReason(reason) {
      if (!reason) return "unknown";
      switch (reason) {
        case "STOP":
          return "stop";
        case "MAX_TOKENS":
          return "length";
        case "SAFETY":
        case "RECITATION":
          return "blocked";
        default:
          return "unknown";
      }
    }
    function fromGeminiCandidate(candidate, jsonMode = false) {
      var _a;
      const parts = ((_a = candidate.content) == null ? void 0 : _a.parts) || [];
      const genkitCandidate = {
        index: candidate.index || 0,
        message: {
          role: "model",
          content: parts.map(
            (part, index) => fromGeminiPart(part, jsonMode, index.toString())
          )
        },
        finishReason: fromGeminiFinishReason(candidate.finishReason),
        finishMessage: candidate.finishMessage,
        custom: {
          safetyRatings: candidate.safetyRatings,
          citationMetadata: candidate.citationMetadata
        }
      };
      return genkitCandidate;
    }
    function cleanSchema(schema) {
      const out = structuredClone(schema);
      for (const key in out) {
        if (key === "$schema" || key === "additionalProperties") {
          delete out[key];
          continue;
        }
        if (typeof out[key] === "object") {
          out[key] = cleanSchema(out[key]);
        }
        if (key === "type" && Array.isArray(out[key])) {
          out[key] = out[key].find((t) => t !== "null");
        }
      }
      return out;
    }
    function defineGoogleAIModel2({
      ai,
      name,
      apiKey: apiKeyOption,
      apiVersion,
      baseUrl,
      info,
      defaultConfig,
      debugTraces
    }) {
      var _a, _b;
      let apiKey2;
      if (apiKeyOption !== false) {
        apiKey2 = apiKeyOption || (0, import_common2.getApiKeyFromEnvVar)();
        if (!apiKey2) {
          throw new import_genkit2.GenkitError({
            status: "FAILED_PRECONDITION",
            message: "Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai"
          });
        }
      }
      const apiModelName = name.startsWith("googleai/") ? name.substring("googleai/".length) : name;
      const model2 = SUPPORTED_GEMINI_MODELS2[apiModelName] ?? (0, import_model4.modelRef)({
        name: `googleai/${apiModelName}`,
        info: {
          label: `Google AI - ${apiModelName}`,
          supports: {
            multiturn: true,
            media: true,
            tools: true,
            systemRole: true,
            output: ["text", "json"]
          },
          ...info
        },
        configSchema: GeminiConfigSchema2
      });
      const middleware = [];
      if ((_b = (_a = model2.info) == null ? void 0 : _a.supports) == null ? void 0 : _b.media) {
        middleware.push(
          (0, import_middleware2.downloadRequestMedia)({
            maxBytes: 1024 * 1024 * 10,
            // don't downlaod files that have been uploaded using the Files API
            filter: (part) => {
              try {
                const url = new URL(part.media.url);
                if (
                  // Gemini can handle these URLs
                  [
                    "generativelanguage.googleapis.com",
                    "www.youtube.com",
                    "youtube.com",
                    "youtu.be"
                  ].includes(url.hostname)
                )
                  return false;
              } catch {
              }
              return true;
            }
          })
        );
      }
      return ai.defineModel(
        {
          apiVersion: "v2",
          name: model2.name,
          ...model2.info,
          configSchema: model2.configSchema,
          use: middleware
        },
        async (request, { streamingRequested, sendChunk, abortSignal }) => {
          var _a2, _b2, _c, _d, _e, _f;
          const options = { apiClient: (0, import_common2.getGenkitClientHeader)() };
          if (apiVersion) {
            options.apiVersion = apiVersion;
          }
          if (apiVersion) {
            options.baseUrl = baseUrl;
          }
          const requestConfig = {
            ...defaultConfig,
            ...request.config
          };
          const messages = [...request.messages];
          if (messages.length === 0) throw new Error("No messages provided.");
          let systemInstruction = void 0;
          if ((_b2 = (_a2 = model2.info) == null ? void 0 : _a2.supports) == null ? void 0 : _b2.systemRole) {
            const systemMessage = messages.find((m) => m.role === "system");
            if (systemMessage) {
              messages.splice(messages.indexOf(systemMessage), 1);
              systemInstruction = toGeminiSystemInstruction(systemMessage);
            }
          }
          const tools = [];
          if ((_c = request.tools) == null ? void 0 : _c.length) {
            tools.push({
              functionDeclarations: request.tools.map(toGeminiTool)
            });
          }
          const {
            apiKey: apiKeyFromConfig,
            safetySettings: safetySettingsFromConfig,
            codeExecution: codeExecutionFromConfig,
            version: versionFromConfig,
            functionCallingConfig,
            googleSearchRetrieval,
            tools: toolsFromConfig,
            ...restOfConfigOptions
          } = requestConfig;
          if (codeExecutionFromConfig) {
            tools.push({
              codeExecution: request.config.codeExecution === true ? {} : request.config.codeExecution
            });
          }
          if (toolsFromConfig) {
            tools.push(...toolsFromConfig);
          }
          if (googleSearchRetrieval) {
            tools.push({
              googleSearch: googleSearchRetrieval === true ? {} : googleSearchRetrieval
            });
          }
          let toolConfig;
          if (functionCallingConfig) {
            toolConfig = {
              functionCallingConfig: {
                allowedFunctionNames: functionCallingConfig.allowedFunctionNames,
                mode: toFunctionModeEnum(functionCallingConfig.mode)
              }
            };
          } else if (request.toolChoice) {
            toolConfig = {
              functionCallingConfig: {
                mode: toGeminiFunctionModeEnum(request.toolChoice)
              }
            };
          }
          const jsonMode = ((_d = request.output) == null ? void 0 : _d.format) === "json" || ((_e = request.output) == null ? void 0 : _e.contentType) === "application/json" && tools.length === 0;
          const generationConfig = {
            ...restOfConfigOptions,
            candidateCount: request.candidates || void 0,
            responseMimeType: jsonMode ? "application/json" : void 0
          };
          if (((_f = request.output) == null ? void 0 : _f.constrained) && jsonMode) {
            generationConfig.responseSchema = cleanSchema(request.output.schema);
          }
          const msg = toGeminiMessage(messages[messages.length - 1], model2);
          const fromJSONModeScopedGeminiCandidate = (candidate) => {
            return fromGeminiCandidate(candidate, jsonMode);
          };
          const chatRequest = {
            systemInstruction,
            generationConfig,
            tools: tools.length ? tools : void 0,
            toolConfig,
            history: messages.slice(0, -1).map((message) => toGeminiMessage(message, model2)),
            safetySettings: safetySettingsFromConfig
          };
          const modelVersion = versionFromConfig || model2.version || apiModelName;
          const cacheConfigDetails = (0, import_utils.extractCacheConfig)(request);
          const { chatRequest: updatedChatRequest, cache } = await (0, import_context_caching.handleCacheIfNeeded)(
            apiKey2,
            request,
            chatRequest,
            modelVersion,
            cacheConfigDetails
          );
          if (!apiKeyFromConfig && !apiKey2) {
            throw new import_genkit2.GenkitError({
              status: "INVALID_ARGUMENT",
              message: "GoogleAI plugin was initialized with {apiKey: false} but no apiKey configuration was passed at call time."
            });
          }
          const client = new import_generative_ai.GoogleGenerativeAI(apiKeyFromConfig || apiKey2);
          let genModel;
          if (cache) {
            genModel = client.getGenerativeModelFromCachedContent(
              cache,
              {
                model: modelVersion
              },
              options
            );
          } else {
            genModel = client.getGenerativeModel(
              {
                model: modelVersion
              },
              options
            );
          }
          const callGemini = async () => {
            var _a3, _b3;
            let response;
            if (streamingRequested) {
              const result = await genModel.startChat(updatedChatRequest).sendMessageStream(msg.parts, { ...options, signal: abortSignal });
              const chunks = [];
              for await (const item of result.stream) {
                chunks.push(item);
                (_a3 = item.candidates) == null ? void 0 : _a3.forEach(
                  (candidate) => {
                    const c = fromJSONModeScopedGeminiCandidate(candidate);
                    sendChunk({
                      index: c.index,
                      content: c.message.content
                    });
                  }
                );
              }
              response = aggregateResponses(chunks);
            } else {
              const result = await genModel.startChat(updatedChatRequest).sendMessage(msg.parts, { ...options, signal: abortSignal });
              response = result.response;
            }
            const candidates = response.candidates || [];
            if ((_b3 = response.candidates) == null ? void 0 : _b3["undefined"]) {
              candidates.push(response.candidates["undefined"]);
            }
            if (!candidates.length) {
              throw new import_genkit2.GenkitError({
                status: "FAILED_PRECONDITION",
                message: "No valid candidates returned."
              });
            }
            const candidateData = candidates.map(fromJSONModeScopedGeminiCandidate) || [];
            const usageMetadata = response.usageMetadata;
            return {
              candidates: candidateData,
              custom: response,
              usage: {
                ...(0, import_model4.getBasicUsageStats)(request.messages, candidateData),
                inputTokens: usageMetadata == null ? void 0 : usageMetadata.promptTokenCount,
                outputTokens: usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount,
                thoughtsTokens: usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount,
                totalTokens: usageMetadata == null ? void 0 : usageMetadata.totalTokenCount,
                cachedContentTokens: usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount
              }
            };
          };
          return debugTraces ? await (0, import_tracing2.runInNewSpan)(
            ai.registry,
            {
              metadata: {
                name: streamingRequested ? "sendMessageStream" : "sendMessage"
              }
            },
            async (metadata) => {
              metadata.input = {
                sdk: "@google/generative-ai",
                cache,
                model: genModel.model,
                chatOptions: updatedChatRequest,
                parts: msg.parts,
                options
              };
              const response = await callGemini();
              metadata.output = response.custom;
              return response;
            }
          ) : await callGemini();
        }
      );
    }
    function toFunctionModeEnum(configEnum) {
      if (configEnum === void 0) {
        return void 0;
      }
      switch (configEnum) {
        case "MODE_UNSPECIFIED": {
          return import_generative_ai.FunctionCallingMode.MODE_UNSPECIFIED;
        }
        case "ANY": {
          return import_generative_ai.FunctionCallingMode.ANY;
        }
        case "AUTO": {
          return import_generative_ai.FunctionCallingMode.AUTO;
        }
        case "NONE": {
          return import_generative_ai.FunctionCallingMode.NONE;
        }
        default:
          throw new Error(`unsupported function calling mode: ${configEnum}`);
      }
    }
    function toGeminiFunctionModeEnum(genkitMode) {
      if (genkitMode === void 0) {
        return void 0;
      }
      switch (genkitMode) {
        case "required": {
          return import_generative_ai.FunctionCallingMode.ANY;
        }
        case "auto": {
          return import_generative_ai.FunctionCallingMode.AUTO;
        }
        case "none": {
          return import_generative_ai.FunctionCallingMode.NONE;
        }
        default:
          throw new Error(`unsupported function calling mode: ${genkitMode}`);
      }
    }
    function aggregateResponses(responses) {
      const lastResponse = responses[responses.length - 1];
      const aggregatedResponse = {
        promptFeedback: lastResponse == null ? void 0 : lastResponse.promptFeedback
      };
      for (const response of responses) {
        if (response.candidates) {
          let candidateIndex = 0;
          for (const candidate of response.candidates) {
            if (!aggregatedResponse.candidates) {
              aggregatedResponse.candidates = [];
            }
            if (!aggregatedResponse.candidates[candidateIndex]) {
              aggregatedResponse.candidates[candidateIndex] = {
                index: candidateIndex
              };
            }
            aggregatedResponse.candidates[candidateIndex].citationMetadata = candidate.citationMetadata;
            aggregatedResponse.candidates[candidateIndex].groundingMetadata = candidate.groundingMetadata;
            aggregatedResponse.candidates[candidateIndex].finishReason = candidate.finishReason;
            aggregatedResponse.candidates[candidateIndex].finishMessage = candidate.finishMessage;
            aggregatedResponse.candidates[candidateIndex].safetyRatings = candidate.safetyRatings;
            if (candidate.content && candidate.content.parts) {
              if (!aggregatedResponse.candidates[candidateIndex].content) {
                aggregatedResponse.candidates[candidateIndex].content = {
                  role: candidate.content.role || "user",
                  parts: []
                };
              }
              for (const part of candidate.content.parts) {
                const newPart = {};
                if (part.text) {
                  newPart.text = part.text;
                }
                if (part.thought) {
                  newPart.thought = part.thought;
                }
                if (part.thoughtSignature) {
                  newPart.thoughtSignature = part.thoughtSignature;
                }
                if (part.functionCall) {
                  newPart.functionCall = part.functionCall;
                }
                if (part.executableCode) {
                  newPart.executableCode = part.executableCode;
                }
                if (part.codeExecutionResult) {
                  newPart.codeExecutionResult = part.codeExecutionResult;
                }
                if (Object.keys(newPart).length === 0) {
                  newPart.text = "";
                }
                aggregatedResponse.candidates[candidateIndex].content.parts.push(
                  newPart
                );
              }
            }
          }
          candidateIndex++;
        }
        if (response.usageMetadata) {
          aggregatedResponse.usageMetadata = response.usageMetadata;
        }
      }
      return aggregatedResponse;
    }
  }
});

// node_modules/@genkit-ai/googleai/lib/predict.js
var require_predict = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/predict.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var predict_exports = {};
    __export2(predict_exports, {
      checkOp: () => checkOp,
      predictModel: () => predictModel
    });
    module.exports = __toCommonJS(predict_exports);
    var import_common2 = require_common2();
    function predictEndpoint(options) {
      return `https://generativelanguage.googleapis.com/${options.apiVersion}/models/${options.model}:${options.method}?key=${options.apiKey}`;
    }
    function opCheckEndpoint(options) {
      return `https://generativelanguage.googleapis.com/${options.apiVersion}/${options.operation}?key=${options.apiKey}`;
    }
    function predictModel(model2, apiKey2, method) {
      return async (instances, parameters) => {
        const fetch2 = (await import("./src-D26GFCO2.js")).default;
        const req = {
          instances,
          parameters
        };
        const response = await fetch2(
          predictEndpoint({
            model: model2,
            apiVersion: "v1beta",
            apiKey: apiKey2,
            method
          }),
          {
            method: "POST",
            body: JSON.stringify(req),
            headers: {
              "Content-Type": "application/json",
              "X-Goog-Api-Client": (0, import_common2.getGenkitClientHeader)()
            }
          }
        );
        if (!response.ok) {
          throw new Error(
            `Error from Gemini AI predict: HTTP ${response.status}: ${await response.text()}`
          );
        }
        return await response.json();
      };
    }
    async function checkOp(operation, apiKey2) {
      const fetch2 = (await import("./src-D26GFCO2.js")).default;
      const response = await fetch2(
        opCheckEndpoint({
          apiVersion: "v1beta",
          operation,
          apiKey: apiKey2
        }),
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            "X-Goog-Api-Client": (0, import_common2.getGenkitClientHeader)()
          }
        }
      );
      if (!response.ok) {
        throw new Error(
          `Error from operation API: HTTP ${response.status}: ${await response.text()}`
        );
      }
      return await response.json();
    }
  }
});

// node_modules/@genkit-ai/googleai/lib/imagen.js
var require_imagen = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/imagen.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var imagen_exports = {};
    __export2(imagen_exports, {
      GENERIC_IMAGEN_INFO: () => GENERIC_IMAGEN_INFO2,
      ImagenConfigSchema: () => ImagenConfigSchema2,
      defineImagenModel: () => defineImagenModel2
    });
    module.exports = __toCommonJS(imagen_exports);
    var import_genkit2 = require_lib();
    var import_model4 = require_model2();
    var import_common2 = require_common2();
    var import_predict = require_predict();
    var ImagenConfigSchema2 = import_genkit2.z.object({
      numberOfImages: import_genkit2.z.number().describe(
        "The number of images to generate, from 1 to 4 (inclusive). The default is 1."
      ).optional(),
      aspectRatio: import_genkit2.z.enum(["1:1", "9:16", "16:9", "3:4", "4:3"]).describe("Desired aspect ratio of the output image.").optional(),
      personGeneration: import_genkit2.z.enum(["dont_allow", "allow_adult", "allow_all"]).describe(
        "Control if/how images of people will be generated by the model."
      ).optional()
    }).passthrough();
    function toParameters(request) {
      var _a;
      const out = {
        sampleCount: ((_a = request.config) == null ? void 0 : _a.numberOfImages) ?? 1,
        ...request == null ? void 0 : request.config
      };
      for (const k in out) {
        if (!out[k]) delete out[k];
      }
      return out;
    }
    function extractText(request) {
      return request.messages.at(-1).content.map((c) => c.text || "").join("");
    }
    function extractBaseImage(request) {
      var _a, _b, _c;
      return (_c = (_b = (_a = request.messages.at(-1)) == null ? void 0 : _a.content.find((p) => !!p.media)) == null ? void 0 : _b.media) == null ? void 0 : _c.url.split(",")[1];
    }
    var GENERIC_IMAGEN_INFO2 = {
      label: `Google AI - Generic Imagen`,
      supports: {
        media: true,
        multiturn: false,
        tools: false,
        systemRole: false,
        output: ["media"]
      }
    };
    function defineImagenModel2(ai, name, apiKey2) {
      if (apiKey2 !== false) {
        apiKey2 = apiKey2 || (0, import_common2.getApiKeyFromEnvVar)();
        if (!apiKey2) {
          throw new import_genkit2.GenkitError({
            status: "FAILED_PRECONDITION",
            message: "Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai"
          });
        }
      }
      const modelName = `googleai/${name}`;
      const model2 = (0, import_model4.modelRef)({
        name: modelName,
        info: {
          ...GENERIC_IMAGEN_INFO2,
          label: `Google AI - ${name}`
        },
        configSchema: ImagenConfigSchema2
      });
      return ai.defineModel(
        {
          name: modelName,
          ...model2.info,
          configSchema: ImagenConfigSchema2
        },
        async (request) => {
          const instance = {
            prompt: extractText(request)
          };
          const baseImage = extractBaseImage(request);
          if (baseImage) {
            instance.image = { bytesBase64Encoded: baseImage };
          }
          const predictClient = (0, import_predict.predictModel)(model2.version || name, apiKey2, "predict");
          const response = await predictClient([instance], toParameters(request));
          if (!response.predictions || response.predictions.length == 0) {
            throw new Error(
              "Model returned no predictions. Possibly due to content filters."
            );
          }
          const message = {
            role: "model",
            content: []
          };
          response.predictions.forEach((p, i) => {
            const b64data = p.bytesBase64Encoded;
            const mimeType = p.mimeType;
            message.content.push({
              media: {
                url: `data:${mimeType};base64,${b64data}`,
                contentType: mimeType
              }
            });
          });
          return {
            finishReason: "stop",
            message,
            usage: (0, import_model4.getBasicUsageStats)(request.messages, message),
            custom: response
          };
        }
      );
    }
  }
});

// node_modules/@genkit-ai/googleai/lib/list-models.js
var require_list_models = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/list-models.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var list_models_exports = {};
    __export2(list_models_exports, {
      listModels: () => listModels2
    });
    module.exports = __toCommonJS(list_models_exports);
    async function listModels2(baseUrl, apiKey2) {
      const res = await fetch(
        `${baseUrl}/v1beta/models?pageSize=1000&key=${apiKey2}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json"
          }
        }
      );
      const modelResponse = JSON.parse(await res.text());
      return modelResponse.models;
    }
  }
});

// node_modules/@genkit-ai/googleai/lib/veo.js
var require_veo = __commonJS({
  "node_modules/@genkit-ai/googleai/lib/veo.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var veo_exports = {};
    __export2(veo_exports, {
      GENERIC_VEO_INFO: () => GENERIC_VEO_INFO2,
      VeoConfigSchema: () => VeoConfigSchema2,
      defineVeoModel: () => defineVeoModel2
    });
    module.exports = __toCommonJS(veo_exports);
    var import_genkit2 = require_lib();
    var import_model4 = require_model2();
    var import_common2 = require_common2();
    var import_predict = require_predict();
    var VeoConfigSchema2 = import_genkit2.z.object({
      // NOTE: Documentation notes numberOfVideos parameter to pick the number of
      // output videos, but this setting does not seem to work
      negativePrompt: import_genkit2.z.string().optional(),
      aspectRatio: import_genkit2.z.enum(["9:16", "16:9"]).describe("Desired aspect ratio of the output video.").optional(),
      personGeneration: import_genkit2.z.enum(["dont_allow", "allow_adult", "allow_all"]).describe(
        "Control if/how images of people will be generated by the model."
      ).optional(),
      durationSeconds: import_genkit2.z.number().step(1).min(5).max(8).describe("Length of each output video in seconds, between 5 and 8.").optional(),
      enhance_prompt: import_genkit2.z.boolean().describe("Enable or disable the prompt rewriter. Enabled by default.").optional()
    }).passthrough();
    function extractText(request) {
      return request.messages.at(-1).content.map((c) => c.text || "").join("");
    }
    function toParameters(request) {
      const out = {
        ...request == null ? void 0 : request.config
      };
      for (const k in out) {
        if (!out[k]) delete out[k];
      }
      return out;
    }
    function extractImage(request) {
      var _a, _b;
      const media = (_b = (_a = request.messages.at(-1)) == null ? void 0 : _a.content.find((p) => !!p.media)) == null ? void 0 : _b.media;
      if (media) {
        const img = media == null ? void 0 : media.url.split(",")[1];
        return {
          bytesBase64Encoded: img,
          mimeType: media.contentType
        };
      }
      return void 0;
    }
    var GENERIC_VEO_INFO2 = {
      label: `Google AI - Generic Veo`,
      supports: {
        media: true,
        multiturn: false,
        tools: false,
        systemRole: false,
        output: ["media"],
        longRunning: true
      }
    };
    function defineVeoModel2(ai, name, apiKey2) {
      if (apiKey2 !== false) {
        apiKey2 = apiKey2 || (0, import_common2.getApiKeyFromEnvVar)();
        if (!apiKey2) {
          throw new import_genkit2.GenkitError({
            status: "FAILED_PRECONDITION",
            message: "Please pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable.\nFor more details see https://genkit.dev/docs/plugins/google-genai"
          });
        }
      }
      const modelName = `googleai/${name}`;
      const model2 = (0, import_model4.modelRef)({
        name: modelName,
        info: {
          ...GENERIC_VEO_INFO2,
          label: `Google AI - ${name}`
        },
        configSchema: VeoConfigSchema2
      });
      return ai.defineBackgroundModel({
        name: modelName,
        ...model2.info,
        configSchema: VeoConfigSchema2,
        async start(request) {
          const instance = {
            prompt: extractText(request)
          };
          const image = extractImage(request);
          if (image) {
            instance.image = image;
          }
          const predictClient = (0, import_predict.predictModel)(model2.version || name, apiKey2, "predictLongRunning");
          const response = await predictClient([instance], toParameters(request));
          return toGenkitOp(response);
        },
        async check(operation) {
          const newOp = await (0, import_predict.checkOp)(operation.id, apiKey2);
          return toGenkitOp(newOp);
        }
      });
    }
    function toGenkitOp(apiOp) {
      const res = { id: apiOp.name };
      if (apiOp.done !== void 0) {
        res.done = apiOp.done;
      }
      if (apiOp.error) {
        res.error = { message: apiOp.error.message };
      }
      if (apiOp.response && apiOp.response.generateVideoResponse && apiOp.response.generateVideoResponse.generatedSamples) {
        res.output = {
          finishReason: "stop",
          raw: apiOp.response,
          message: {
            role: "model",
            content: apiOp.response.generateVideoResponse.generatedSamples.map(
              (s) => {
                return {
                  media: {
                    url: s.video.uri
                  }
                };
              }
            )
          }
        };
      }
      return res;
    }
  }
});

// node_modules/@genkit-ai/core/lib/logging.mjs
var LOG_LEVELS = ["debug", "info", "warn", "error"];
var loggerKey = "__genkit_logger";
var _defaultLogger = {
  shouldLog(targetLevel) {
    return LOG_LEVELS.indexOf(this.level) <= LOG_LEVELS.indexOf(targetLevel);
  },
  debug(...args) {
    this.shouldLog("debug") && console.debug(...args);
  },
  info(...args) {
    this.shouldLog("info") && console.info(...args);
  },
  warn(...args) {
    this.shouldLog("warn") && console.warn(...args);
  },
  error(...args) {
    this.shouldLog("error") && console.error(...args);
  },
  level: "info"
};
function getLogger() {
  if (!global[loggerKey]) {
    global[loggerKey] = _defaultLogger;
  }
  return global[loggerKey];
}
var Logger = class {
  constructor() {
    __publicField(this, "defaultLogger", _defaultLogger);
  }
  init(fn) {
    global[loggerKey] = fn;
  }
  info(...args) {
    getLogger().info.apply(getLogger(), args);
  }
  debug(...args) {
    getLogger().debug.apply(getLogger(), args);
  }
  error(...args) {
    getLogger().error.apply(getLogger(), args);
  }
  warn(...args) {
    getLogger().warn.apply(getLogger(), args);
  }
  setLogLevel(level) {
    getLogger().level = level;
  }
  logStructured(msg, metadata) {
    getLogger().info(msg, metadata);
  }
  logStructuredError(msg, metadata) {
    getLogger().error(msg, metadata);
  }
};
var logger = new Logger();

// node_modules/@genkit-ai/ai/lib/model.mjs
var model_exports = {};
__export(model_exports, {
  CustomPartSchema: () => import_document.CustomPartSchema,
  DataPartSchema: () => import_document.DataPartSchema,
  MediaPartSchema: () => import_document.MediaPartSchema,
  TextPartSchema: () => import_document.TextPartSchema,
  ToolRequestPartSchema: () => import_document.ToolRequestPartSchema,
  ToolResponsePartSchema: () => import_document.ToolResponsePartSchema,
  backgroundModel: () => backgroundModel,
  defineBackgroundModel: () => defineBackgroundModel,
  defineGenerateAction: () => import_action.defineGenerateAction,
  defineModel: () => defineModel,
  getBasicUsageStats: () => getBasicUsageStats2,
  model: () => model,
  modelActionMetadata: () => modelActionMetadata,
  modelRef: () => modelRef2,
  resolveModel: () => resolveModel,
  simulateConstrainedGeneration: () => import_middleware.simulateConstrainedGeneration
});

// node_modules/@genkit-ai/core/lib/index.mjs
var lib_exports2 = {};
__export(lib_exports2, {
  GENKIT_CLIENT_HEADER: () => GENKIT_CLIENT_HEADER,
  GENKIT_REFLECTION_API_SPEC_VERSION: () => GENKIT_REFLECTION_API_SPEC_VERSION,
  GENKIT_VERSION: () => GENKIT_VERSION,
  GenkitError: () => import_error.GenkitError,
  OperationSchema: () => import_background_action.OperationSchema,
  UnstableApiError: () => import_error.UnstableApiError,
  UserFacingError: () => import_error.UserFacingError,
  apiKey: () => import_context.apiKey,
  assertUnstable: () => import_error.assertUnstable,
  backgroundAction: () => import_background_action.backgroundAction,
  defineBackgroundAction: () => import_background_action.defineBackgroundAction,
  defineFlow: () => import_flow.defineFlow,
  defineJsonSchema: () => import_schema.defineJsonSchema,
  defineSchema: () => import_schema.defineSchema,
  flow: () => import_flow.flow,
  getAsyncContext: () => import_async_context.getAsyncContext,
  getCallableJSON: () => import_error.getCallableJSON,
  getClientHeader: () => getClientHeader,
  getContext: () => import_context.getContext,
  getHttpStatus: () => import_error.getHttpStatus,
  isBackgroundAction: () => import_background_action.isBackgroundAction,
  registerBackgroundAction: () => import_background_action.registerBackgroundAction,
  run: () => import_flow.run,
  runWithContext: () => import_context.runWithContext,
  setClientHeader: () => setClientHeader,
  z: () => external_exports
});
var import_version = __toESM(require_version(), 1);
__reExport(lib_exports2, __toESM(require_action(), 1));
var import_async_context = __toESM(require_async_context(), 1);
var import_background_action = __toESM(require_background_action(), 1);
var import_context = __toESM(require_context(), 1);
var import_error = __toESM(require_error(), 1);
var import_flow = __toESM(require_flow(), 1);
__reExport(lib_exports2, __toESM(require_plugin(), 1));
__reExport(lib_exports2, __toESM(require_reflection(), 1));
var import_schema = __toESM(require_schema(), 1);
__reExport(lib_exports2, __toESM(require_telemetryTypes(), 1));
__reExport(lib_exports2, __toESM(require_utils(), 1));
var GENKIT_VERSION = import_version.version;
var GENKIT_CLIENT_HEADER = `genkit-node/${GENKIT_VERSION} gl-node/${process.versions.node}`;
var GENKIT_REFLECTION_API_SPEC_VERSION = 1;
var clientHeaderGlobalKey = "__genkit_ClientHeader";
function getClientHeader() {
  if (global[clientHeaderGlobalKey]) {
    return GENKIT_CLIENT_HEADER + " " + global[clientHeaderGlobalKey];
  }
  return GENKIT_CLIENT_HEADER;
}
function setClientHeader(header) {
  global[clientHeaderGlobalKey] = header;
}

// node_modules/@genkit-ai/core/lib/schema.mjs
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist(), 1);

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  var _a, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e, _f;
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  var _a;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// node_modules/zod-to-json-schema/dist/esm/index.js
var esm_default = zodToJsonSchema;

// node_modules/@genkit-ai/core/lib/schema.mjs
var import_error2 = __toESM(require_error(), 1);
var ajv = new import_ajv.default();
(0, import_ajv_formats.default)(ajv);
var jsonSchemas = /* @__PURE__ */ new WeakMap();
function toJsonSchema({
  jsonSchema,
  schema
}) {
  if (!jsonSchema && !schema) return null;
  if (jsonSchema) return jsonSchema;
  if (jsonSchemas.has(schema)) return jsonSchemas.get(schema);
  const outSchema = esm_default(schema, {
    $refStrategy: "none",
    removeAdditionalStrategy: "strict"
  });
  jsonSchemas.set(schema, outSchema);
  return outSchema;
}

// node_modules/@genkit-ai/ai/lib/model.mjs
var import_node_perf_hooks = __toESM(require_node_perf_hooks(), 1);
var import_document = __toESM(require_document(), 1);
var import_model_types = __toESM(require_model_types(), 1);
var import_middleware = __toESM(require_middleware(), 1);
var import_action = __toESM(require_action2(), 1);
__reExport(model_exports, __toESM(require_model_types(), 1));
function model(options, runner) {
  const act = (0, lib_exports2.action)(modelActionOptions(options), (input, ctx) => {
    const startTimeMs = import_node_perf_hooks.performance.now();
    return runner(input, ctx).then((response) => {
      const timedResponse = {
        ...response,
        latencyMs: import_node_perf_hooks.performance.now() - startTimeMs
      };
      return timedResponse;
    });
  });
  Object.assign(act, {
    __configSchema: options.configSchema || external_exports.unknown()
  });
  return act;
}
function modelActionOptions(options) {
  const label = options.label || options.name;
  const middleware = getModelMiddleware(options);
  return {
    actionType: "model",
    name: options.name,
    description: label,
    inputSchema: import_model_types.GenerateRequestSchema,
    outputSchema: import_model_types.GenerateResponseSchema,
    metadata: {
      model: {
        label,
        customOptions: options.configSchema ? toJsonSchema({ schema: options.configSchema }) : void 0,
        versions: options.versions,
        supports: options.supports
      }
    },
    use: middleware
  };
}
function defineModel(registry, options, runner) {
  const act = (0, lib_exports2.defineAction)(
    registry,
    modelActionOptions(options),
    (input, ctx) => {
      const startTimeMs = import_node_perf_hooks.performance.now();
      const secondParam = options.apiVersion === "v2" ? ctx : ctx.streamingRequested ? ctx.sendChunk : void 0;
      return runner(input, secondParam).then((response) => {
        const timedResponse = {
          ...response,
          latencyMs: import_node_perf_hooks.performance.now() - startTimeMs
        };
        return timedResponse;
      });
    }
  );
  Object.assign(act, {
    __configSchema: options.configSchema || external_exports.unknown()
  });
  return act;
}
function defineBackgroundModel(registry, options) {
  const act = backgroundModel(options);
  (0, import_background_action.registerBackgroundAction)(registry, act);
  return act;
}
function backgroundModel(options) {
  const label = options.label || options.name;
  const middleware = getModelMiddleware(options);
  const act = (0, import_background_action.backgroundAction)({
    actionType: "background-model",
    name: options.name,
    description: label,
    inputSchema: import_model_types.GenerateRequestSchema,
    outputSchema: import_model_types.GenerateResponseSchema,
    metadata: {
      model: {
        label,
        customOptions: options.configSchema ? toJsonSchema({ schema: options.configSchema }) : void 0,
        versions: options.versions,
        supports: options.supports
      }
    },
    use: middleware,
    async start(request) {
      const startTimeMs = import_node_perf_hooks.performance.now();
      const response = await options.start(request);
      Object.assign(response, {
        latencyMs: import_node_perf_hooks.performance.now() - startTimeMs
      });
      return response;
    },
    async check(op) {
      return options.check(op);
    },
    cancel: options.cancel ? async (op) => {
      if (!options.cancel) {
        throw new import_error.GenkitError({
          status: "UNIMPLEMENTED",
          message: "cancel not implemented"
        });
      }
      return options.cancel(op);
    } : void 0
  });
  Object.assign(act, {
    __configSchema: options.configSchema || external_exports.unknown()
  });
  return act;
}
function getModelMiddleware(options) {
  var _a;
  const middleware = options.use || [];
  if (!((_a = options == null ? void 0 : options.supports) == null ? void 0 : _a.context)) middleware.push((0, import_middleware.augmentWithContext)());
  const constratedSimulator = (0, import_middleware.simulateConstrainedGeneration)();
  middleware.push((req, next) => {
    var _a2, _b, _c, _d;
    if (!((_a2 = options == null ? void 0 : options.supports) == null ? void 0 : _a2.constrained) || ((_b = options == null ? void 0 : options.supports) == null ? void 0 : _b.constrained) === "none" || ((_c = options == null ? void 0 : options.supports) == null ? void 0 : _c.constrained) === "no-tools" && (((_d = req.tools) == null ? void 0 : _d.length) ?? 0) > 0) {
      return constratedSimulator(req, next);
    }
    return next(req);
  });
  return middleware;
}
function modelActionMetadata({
  name,
  info,
  configSchema,
  background
}) {
  return {
    actionType: background ? "background-model" : "model",
    name,
    inputJsonSchema: toJsonSchema({ schema: import_model_types.GenerateRequestSchema }),
    outputJsonSchema: background ? toJsonSchema({ schema: import_background_action.OperationSchema }) : toJsonSchema({ schema: import_model_types.GenerateResponseSchema }),
    metadata: {
      model: {
        ...info,
        customOptions: configSchema ? toJsonSchema({ schema: configSchema }) : void 0
      }
    }
  };
}
function modelRef2(options) {
  let name = options.name;
  if (options.namespace && !name.startsWith(options.namespace + "/")) {
    name = `${options.namespace}/${name}`;
  }
  const ref = {
    ...options,
    name
  };
  ref.withConfig = (cfg) => {
    return modelRef2({
      ...options,
      name,
      config: cfg
    });
  };
  ref.withVersion = (version2) => {
    return modelRef2({
      ...options,
      name,
      version: version2
    });
  };
  return ref;
}
function getBasicUsageStats2(input, response) {
  const inputCounts = getPartCounts(input.flatMap((md) => md.content));
  const outputCounts = getPartCounts(
    Array.isArray(response) ? response.flatMap((c) => c.message.content) : response.content
  );
  return {
    inputCharacters: inputCounts.characters,
    inputImages: inputCounts.images,
    inputVideos: inputCounts.videos,
    inputAudioFiles: inputCounts.audio,
    outputCharacters: outputCounts.characters,
    outputImages: outputCounts.images,
    outputVideos: outputCounts.videos,
    outputAudioFiles: outputCounts.audio
  };
}
function getPartCounts(parts) {
  return parts.reduce(
    (counts, part) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const isImage = ((_b = (_a = part.media) == null ? void 0 : _a.contentType) == null ? void 0 : _b.startsWith("image")) || ((_d = (_c = part.media) == null ? void 0 : _c.url) == null ? void 0 : _d.startsWith("data:image"));
      const isVideo = ((_f = (_e = part.media) == null ? void 0 : _e.contentType) == null ? void 0 : _f.startsWith("video")) || ((_h = (_g = part.media) == null ? void 0 : _g.url) == null ? void 0 : _h.startsWith("data:video"));
      const isAudio = ((_j = (_i = part.media) == null ? void 0 : _i.contentType) == null ? void 0 : _j.startsWith("audio")) || ((_l = (_k = part.media) == null ? void 0 : _k.url) == null ? void 0 : _l.startsWith("data:audio"));
      return {
        characters: counts.characters + (((_m = part.text) == null ? void 0 : _m.length) || 0),
        images: counts.images + (isImage ? 1 : 0),
        videos: counts.videos + (isVideo ? 1 : 0),
        audio: counts.audio + (isAudio ? 1 : 0)
      };
    },
    { characters: 0, images: 0, videos: 0, audio: 0 }
  );
}
async function resolveModel(registry, model2, options) {
  var _a, _b;
  let out;
  let modelId;
  if (!model2) {
    model2 = await registry.lookupValue("defaultModel", "defaultModel");
  }
  if (!model2) {
    throw new import_error.GenkitError({
      status: "INVALID_ARGUMENT",
      message: "Must supply a `model` to `generate()` calls."
    });
  }
  if (typeof model2 === "string") {
    modelId = model2;
    out = { modelAction: await lookupModel(registry, model2) };
  } else if (model2.hasOwnProperty("__action")) {
    modelId = model2.__action.name;
    out = { modelAction: model2 };
  } else {
    const ref = model2;
    modelId = ref.name;
    out = {
      modelAction: await lookupModel(registry, ref.name),
      config: {
        ...ref.config
      },
      version: ref.version
    };
  }
  if (!out.modelAction) {
    throw new import_error.GenkitError({
      status: "NOT_FOUND",
      message: `Model '${modelId}' not found`
    });
  }
  if ((options == null ? void 0 : options.warnDeprecated) && ((_b = (_a = out.modelAction.__action.metadata) == null ? void 0 : _a.model) == null ? void 0 : _b.stage) === "deprecated") {
    logger.warn(
      `Model '${out.modelAction.__action.name}' is deprecated and may be removed in a future release.`
    );
  }
  return out;
}
async function lookupModel(registry, model2) {
  return await registry.lookupAction(`/model/${model2}`) || await registry.lookupAction(`/background-model/${model2}`);
}

// node_modules/@genkit-ai/ai/lib/embedder.mjs
var import_document2 = __toESM(require_document(), 1);
var EmbeddingSchema = external_exports.object({
  embedding: external_exports.array(external_exports.number()),
  metadata: external_exports.record(external_exports.string(), external_exports.unknown()).optional()
});
var EmbedRequestSchema = external_exports.object({
  input: external_exports.array(import_document2.DocumentDataSchema),
  options: external_exports.any().optional()
});
var EmbedResponseSchema = external_exports.object({
  embeddings: external_exports.array(EmbeddingSchema)
  // TODO: stats, etc.
});
var EmbedderInfoSchema2 = external_exports.object({
  /** Friendly label for this model (e.g. "Google AI - Gemini Pro") */
  label: external_exports.string().optional(),
  /** Supported model capabilities. */
  supports: external_exports.object({
    /** Model can input this type of data. */
    input: external_exports.array(external_exports.enum(["text", "image", "video"])).optional(),
    /** Model can support multiple languages */
    multilingual: external_exports.boolean().optional()
  }).optional(),
  /** Embedding dimension */
  dimensions: external_exports.number().optional()
});

// node_modules/@genkit-ai/core/lib/tracing.mjs
var tracing_exports = {};
__export(tracing_exports, {
  enableTelemetry: () => enableTelemetry,
  ensureBasicTelemetryInstrumentation: () => ensureBasicTelemetryInstrumentation,
  flushTracing: () => flushTracing,
  setTelemetryProvider: () => setTelemetryProvider
});
var import_error3 = __toESM(require_error(), 1);
var import_logging3 = __toESM(require_logging(), 1);
__reExport(tracing_exports, __toESM(require_exporter(), 1));
__reExport(tracing_exports, __toESM(require_instrumentation(), 1));
__reExport(tracing_exports, __toESM(require_types(), 1));
var instrumentationKey = "__GENKIT_TELEMETRY_INSTRUMENTED";
var telemetryProviderKey = "__GENKIT_TELEMETRY_PROVIDER";
async function ensureBasicTelemetryInstrumentation() {
  await checkFirebaseMonitoringAutoInit();
  if (global[instrumentationKey]) {
    return await global[instrumentationKey];
  }
  await enableTelemetry({});
}
async function checkFirebaseMonitoringAutoInit() {
  if (!global[instrumentationKey] && process.env.ENABLE_FIREBASE_MONITORING === "true") {
    try {
      const importModule = new Function(
        "moduleName",
        "return import(moduleName)"
      );
      const firebaseModule = await importModule("@genkit-ai/firebase");
      firebaseModule.enableFirebaseTelemetry();
    } catch (e) {
      import_logging3.logger.warn(
        "It looks like you're trying to enable firebase monitoring, but haven't installed the firebase plugin. Please run `npm i --save @genkit-ai/firebase` and redeploy."
      );
    }
  }
}
function getTelemetryProvider() {
  if (global[telemetryProviderKey]) {
    return global[telemetryProviderKey];
  }
  throw new import_error3.GenkitError({
    status: "FAILED_PRECONDITION",
    message: "TelemetryProvider is not initialized."
  });
}
function setTelemetryProvider(provider) {
  if (global[telemetryProviderKey]) return;
  global[telemetryProviderKey] = provider;
}
async function enableTelemetry(telemetryConfig) {
  global[instrumentationKey] = telemetryConfig instanceof Promise ? telemetryConfig : Promise.resolve();
  return getTelemetryProvider().enableTelemetry(telemetryConfig);
}
async function flushTracing() {
  return getTelemetryProvider().flushTracing();
}

// node_modules/@genkit-ai/ai/lib/evaluator.mjs
var import_crypto = __toESM(require_crypto(), 1);
var ATTR_PREFIX = "genkit";
var SPAN_STATE_ATTR = ATTR_PREFIX + ":state";
var BaseDataPointSchema = external_exports.object({
  input: external_exports.unknown(),
  output: external_exports.unknown().optional(),
  context: external_exports.array(external_exports.unknown()).optional(),
  reference: external_exports.unknown().optional(),
  testCaseId: external_exports.string().optional(),
  traceIds: external_exports.array(external_exports.string()).optional()
});
var BaseEvalDataPointSchema = BaseDataPointSchema.extend({
  testCaseId: external_exports.string()
});
var EvalStatusEnumSchema = external_exports.enum(["UNKNOWN", "PASS", "FAIL"]);
var EvalStatusEnum = ((EvalStatusEnum2) => {
  EvalStatusEnum2["UNKNOWN"] = "UNKNOWN";
  EvalStatusEnum2["PASS"] = "PASS";
  EvalStatusEnum2["FAIL"] = "FAIL";
  return EvalStatusEnum2;
})(EvalStatusEnum || {});
var ScoreSchema = external_exports.object({
  id: external_exports.string().describe(
    "Optional ID to differentiate different scores if applying in a single evaluation"
  ).optional(),
  score: external_exports.union([external_exports.number(), external_exports.string(), external_exports.boolean()]).optional(),
  status: EvalStatusEnumSchema.optional(),
  error: external_exports.string().optional(),
  details: external_exports.object({
    reasoning: external_exports.string().optional()
  }).passthrough().optional()
});
var EvalResponseSchema = external_exports.object({
  sampleIndex: external_exports.number().optional(),
  testCaseId: external_exports.string(),
  traceId: external_exports.string().optional(),
  spanId: external_exports.string().optional(),
  evaluation: external_exports.union([ScoreSchema, external_exports.array(ScoreSchema)])
});
var EvalResponsesSchema = external_exports.array(EvalResponseSchema);
var EvalRequestSchema = external_exports.object({
  dataset: external_exports.array(BaseDataPointSchema),
  evalRunId: external_exports.string(),
  options: external_exports.unknown()
});
var EvaluatorInfoSchema = external_exports.object({
  /** Friendly label for this evaluator */
  label: external_exports.string().optional(),
  metrics: external_exports.array(external_exports.string())
});

// node_modules/@genkit-ai/ai/lib/reranker.mjs
var import_document3 = __toESM(require_document(), 1);
var import_retriever = __toESM(require_retriever(), 1);
var RankedDocumentMetadataSchema = external_exports.object({
  score: external_exports.number()
  // Enforces that 'score' must be a number
}).passthrough();
var RankedDocumentDataSchema = external_exports.object({
  content: external_exports.array(import_document3.PartSchema),
  metadata: RankedDocumentMetadataSchema
});
var RerankerRequestSchema = external_exports.object({
  query: import_retriever.DocumentDataSchema,
  documents: external_exports.array(import_retriever.DocumentDataSchema),
  options: external_exports.any().optional()
});
var RerankerResponseSchema = external_exports.object({
  documents: external_exports.array(RankedDocumentDataSchema)
});
var RerankerInfoSchema = external_exports.object({
  label: external_exports.string().optional(),
  /** Supported model capabilities. */
  supports: external_exports.object({
    /** Model can process media as part of the prompt (multimodal input). */
    media: external_exports.boolean().optional()
  }).optional()
});
var CommonRerankerOptionsSchema = external_exports.object({
  k: external_exports.number().describe("Number of documents to rerank").optional()
});

// node_modules/@genkit-ai/ai/lib/retriever.mjs
var import_document4 = __toESM(require_document(), 1);
var import_document5 = __toESM(require_document(), 1);
var RetrieverRequestSchema = external_exports.object({
  query: import_document4.DocumentDataSchema,
  options: external_exports.any().optional()
});
var RetrieverResponseSchema = external_exports.object({
  documents: external_exports.array(import_document4.DocumentDataSchema)
  // TODO: stats, etc.
});
var IndexerRequestSchema = external_exports.object({
  documents: external_exports.array(import_document4.DocumentDataSchema),
  options: external_exports.any().optional()
});
var RetrieverInfoSchema = external_exports.object({
  label: external_exports.string().optional(),
  /** Supported model capabilities. */
  supports: external_exports.object({
    /** Model can process media as part of the prompt (multimodal input). */
    media: external_exports.boolean().optional()
  }).optional()
});
var CommonRetrieverOptionsSchema = external_exports.object({
  k: external_exports.number().describe("Number of documents to retrieve").optional()
});

// node_modules/genkit/lib/plugin.mjs
function genkitPlugin(pluginName, initFn, resolveFn, listActionsFn) {
  return (genkit2) => ({
    name: pluginName,
    initializer: async () => {
      await initFn(genkit2);
    },
    resolver: async (action6, target) => {
      if (resolveFn) {
        return await resolveFn(genkit2, action6, target);
      }
    },
    listActions: async () => {
      if (listActionsFn) {
        return await listActionsFn();
      }
      return [];
    }
  });
}

// node_modules/@genkit-ai/googleai/lib/index.mjs
var import_common = __toESM(require_common2(), 1);
var import_embedder2 = __toESM(require_embedder3(), 1);
var import_gemini = __toESM(require_gemini(), 1);
var import_imagen = __toESM(require_imagen(), 1);
var import_list_models = __toESM(require_list_models(), 1);
var import_veo = __toESM(require_veo(), 1);
async function initializer(ai, options) {
  let apiVersions = ["v1"];
  if (options == null ? void 0 : options.apiVersion) {
    if (Array.isArray(options == null ? void 0 : options.apiVersion)) {
      apiVersions = options == null ? void 0 : options.apiVersion;
    } else {
      apiVersions = [options == null ? void 0 : options.apiVersion];
    }
  }
  if (apiVersions.includes("v1beta")) {
    Object.keys(import_gemini.SUPPORTED_GEMINI_MODELS).forEach(
      (name) => (0, import_gemini.defineGoogleAIModel)({
        ai,
        name,
        apiKey: options == null ? void 0 : options.apiKey,
        apiVersion: "v1beta",
        baseUrl: options == null ? void 0 : options.baseUrl,
        debugTraces: options == null ? void 0 : options.experimental_debugTraces
      })
    );
  }
  if (apiVersions.includes("v1")) {
    Object.keys(import_gemini.SUPPORTED_GEMINI_MODELS).forEach(
      (name) => (0, import_gemini.defineGoogleAIModel)({
        ai,
        name,
        apiKey: options == null ? void 0 : options.apiKey,
        apiVersion: void 0,
        baseUrl: options == null ? void 0 : options.baseUrl,
        debugTraces: options == null ? void 0 : options.experimental_debugTraces
      })
    );
    Object.keys(import_embedder2.SUPPORTED_MODELS).forEach(
      (name) => (0, import_embedder2.defineGoogleAIEmbedder)(ai, name, { apiKey: options == null ? void 0 : options.apiKey })
    );
  }
  if (options == null ? void 0 : options.models) {
    for (const modelOrRef of options == null ? void 0 : options.models) {
      const modelName = typeof modelOrRef === "string" ? modelOrRef : (
        // strip out the `googleai/` prefix
        modelOrRef.name.split("/")[1]
      );
      const modelRef22 = typeof modelOrRef === "string" ? (0, import_gemini.gemini)(modelOrRef) : modelOrRef;
      (0, import_gemini.defineGoogleAIModel)({
        ai,
        name: modelName,
        apiKey: options == null ? void 0 : options.apiKey,
        baseUrl: options == null ? void 0 : options.baseUrl,
        info: {
          ...modelRef22.info,
          label: `Google AI - ${modelName}`
        },
        debugTraces: options == null ? void 0 : options.experimental_debugTraces
      });
    }
  }
}
async function resolver(ai, actionType, actionName, options) {
  if (actionType === "embedder") {
    resolveEmbedder(ai, actionName, options);
  } else if (actionName.startsWith("veo")) {
    if (actionType === "background-model") {
      (0, import_veo.defineVeoModel)(ai, actionName, options == null ? void 0 : options.apiKey);
    }
  } else if (actionType === "model") {
    resolveModel2(ai, actionName, options);
  }
}
function resolveModel2(ai, actionName, options) {
  if (actionName.startsWith("imagen")) {
    (0, import_imagen.defineImagenModel)(ai, actionName, options == null ? void 0 : options.apiKey);
    return;
  }
  const modelRef22 = (0, import_gemini.gemini)(actionName);
  (0, import_gemini.defineGoogleAIModel)({
    ai,
    name: modelRef22.name,
    apiKey: options == null ? void 0 : options.apiKey,
    baseUrl: options == null ? void 0 : options.baseUrl,
    info: {
      ...modelRef22.info,
      label: `Google AI - ${actionName}`
    },
    debugTraces: options == null ? void 0 : options.experimental_debugTraces
  });
}
function resolveEmbedder(ai, actionName, options) {
  (0, import_embedder2.defineGoogleAIEmbedder)(ai, `googleai/${actionName}`, {
    apiKey: options == null ? void 0 : options.apiKey
  });
}
async function listActions(options) {
  const apiKey2 = (options == null ? void 0 : options.apiKey) || (0, import_common.getApiKeyFromEnvVar)();
  if (!apiKey2) {
    logger.error(
      "Pass in the API key or set the GEMINI_API_KEY or GOOGLE_API_KEY environment variable."
    );
    return [];
  }
  const models = await (0, import_list_models.listModels)(
    (options == null ? void 0 : options.baseUrl) || "https://generativelanguage.googleapis.com",
    apiKey2
  );
  return [
    // Imagen
    ...models.filter(
      (m) => m.supportedGenerationMethods.includes("predict") && m.name.includes("imagen")
    ).filter((m) => !m.description || !m.description.includes("deprecated")).map((m) => {
      const name = m.name.split("/").at(-1);
      return (0, lib_exports.modelActionMetadata)({
        name: `googleai/${name}`,
        info: { ...import_imagen.GENERIC_IMAGEN_INFO },
        configSchema: import_imagen.ImagenConfigSchema
      });
    }),
    // Veo
    ...models.filter(
      (m) => m.supportedGenerationMethods.includes("predictLongRunning") && m.name.includes("veo")
    ).filter((m) => !m.description || !m.description.includes("deprecated")).map((m) => {
      const name = m.name.split("/").at(-1);
      return (0, lib_exports.modelActionMetadata)({
        name: `googleai/${name}`,
        info: { ...import_veo.GENERIC_VEO_INFO },
        configSchema: import_veo.VeoConfigSchema,
        background: true
      });
    }),
    // Models
    ...models.filter((m) => m.supportedGenerationMethods.includes("generateContent")).filter((m) => !m.description || !m.description.includes("deprecated")).map((m) => {
      const ref = (0, import_gemini.gemini)(
        m.name.startsWith("models/") ? m.name.substring("models/".length) : m.name
      );
      return (0, lib_exports.modelActionMetadata)({
        name: ref.name,
        info: ref.info,
        configSchema: import_gemini.GeminiConfigSchema
      });
    }),
    // Embedders
    ...models.filter((m) => m.supportedGenerationMethods.includes("embedContent")).filter((m) => !m.description || !m.description.includes("deprecated")).map((m) => {
      const name = "googleai/" + (m.name.startsWith("models/") ? m.name.substring("models/".length) : m.name);
      return (0, lib_exports.embedderActionMetadata)({
        name,
        configSchema: import_embedder2.GeminiEmbeddingConfigSchema,
        info: {
          dimensions: 768,
          label: `Google Gen AI - ${name}`,
          supports: {
            input: ["text"]
          }
        }
      });
    })
  ];
}
function googleAIPlugin(options) {
  let listActionsCache;
  return genkitPlugin(
    "googleai",
    async (ai) => await initializer(ai, options),
    async (ai, actionType, actionName) => await resolver(ai, actionType, actionName, options),
    async () => {
      if (listActionsCache) return listActionsCache;
      listActionsCache = await listActions(options);
      return listActionsCache;
    }
  );
}
var googleAI = googleAIPlugin;
googleAI.model = (name, config) => {
  if (name.startsWith("imagen")) {
    return modelRef2({
      name: `googleai/${name}`,
      config,
      configSchema: import_imagen.ImagenConfigSchema
    });
  }
  if (name.startsWith("veo")) {
    return modelRef2({
      name: `googleai/${name}`,
      config,
      configSchema: import_veo.VeoConfigSchema
    });
  }
  return modelRef2({
    name: `googleai/${name}`,
    config,
    configSchema: import_gemini.GeminiConfigSchema
  });
};
googleAI.embedder = (name, config) => {
  return (0, lib_exports.embedderRef)({
    name: `googleai/${name}`,
    config,
    configSchema: import_embedder2.GeminiEmbeddingConfigSchema
  });
};
var index_default = googleAI;
var export_gemini = import_gemini.gemini;
var export_gemini10Pro = import_gemini.gemini10Pro;
var export_gemini15Flash = import_gemini.gemini15Flash;
var export_gemini15Flash8b = import_gemini.gemini15Flash8b;
var export_gemini15Pro = import_gemini.gemini15Pro;
var export_gemini20Flash = import_gemini.gemini20Flash;
var export_gemini20FlashExp = import_gemini.gemini20FlashExp;
var export_gemini20FlashLite = import_gemini.gemini20FlashLite;
var export_gemini20ProExp0205 = import_gemini.gemini20ProExp0205;
var export_gemini25FlashLite = import_gemini.gemini25FlashLite;
var export_gemini25FlashPreview0417 = import_gemini.gemini25FlashPreview0417;
var export_gemini25ProExp0325 = import_gemini.gemini25ProExp0325;
var export_gemini25ProPreview0325 = import_gemini.gemini25ProPreview0325;
var export_geminiEmbedding001 = import_embedder2.geminiEmbedding001;
var export_textEmbedding004 = import_embedder2.textEmbedding004;
var export_textEmbeddingGecko001 = import_embedder2.textEmbeddingGecko001;
export {
  index_default as default,
  export_gemini as gemini,
  export_gemini10Pro as gemini10Pro,
  export_gemini15Flash as gemini15Flash,
  export_gemini15Flash8b as gemini15Flash8b,
  export_gemini15Pro as gemini15Pro,
  export_gemini20Flash as gemini20Flash,
  export_gemini20FlashExp as gemini20FlashExp,
  export_gemini20FlashLite as gemini20FlashLite,
  export_gemini20ProExp0205 as gemini20ProExp0205,
  export_gemini25FlashLite as gemini25FlashLite,
  export_gemini25FlashPreview0417 as gemini25FlashPreview0417,
  export_gemini25ProExp0325 as gemini25ProExp0325,
  export_gemini25ProPreview0325 as gemini25ProPreview0325,
  export_geminiEmbedding001 as geminiEmbedding001,
  googleAI,
  googleAIPlugin,
  export_textEmbedding004 as textEmbedding004,
  export_textEmbeddingGecko001 as textEmbeddingGecko001
};
/*! Bundled license information:

genkit/lib/index.js:
  (**
   * @license
   *
   * Copyright 2025 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@google/generative-ai/dist/index.js:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@google/generative-ai/dist/server/index.js:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=@genkit-ai_googleai.js.map
