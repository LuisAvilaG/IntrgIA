{
  "version": 3,
  "sources": ["../../../../node_modules/next/src/server/dynamic-rendering-utils.ts", "../../../../node_modules/next/src/client/components/hooks-server-context.ts", "../../../../node_modules/next/src/client/components/static-generation-bailout.ts", "../../../../node_modules/next/src/server/app-render/async-local-storage.ts", "../../../../node_modules/next/src/server/app-render/work-unit-async-storage-instance.ts", "../../../../node_modules/next/src/client/components/app-router-headers.ts", "../../../../node_modules/next/src/server/app-render/work-unit-async-storage.external.ts", "../../../../node_modules/next/src/server/app-render/work-async-storage-instance.ts", "../../../../node_modules/next/src/server/app-render/work-async-storage.external.ts", "../../../../node_modules/next/src/lib/scheduler.ts", "../../../../node_modules/next/src/lib/metadata/metadata-constants.tsx", "../../../../node_modules/next/src/server/app-render/dynamic-rendering.ts"],
  "sourcesContent": ["export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(public readonly expression: string) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`\n    )\n  }\n}\n\ntype AbortListeners = Array<(err: unknown) => void>\nconst abortListenersBySignal = new WeakMap<AbortSignal, AbortListeners>()\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(new HangingPromiseRejectionError(expression))\n  } else {\n    const hangingPromise = new Promise<T>((_, reject) => {\n      const boundRejection = reject.bind(\n        null,\n        new HangingPromiseRejectionError(expression)\n      )\n      let currentListeners = abortListenersBySignal.get(signal)\n      if (currentListeners) {\n        currentListeners.push(boundRejection)\n      } else {\n        const listeners = [boundRejection]\n        abortListenersBySignal.set(signal, listeners)\n        signal.addEventListener(\n          'abort',\n          () => {\n            for (let i = 0; i < listeners.length; i++) {\n              listeners[i]()\n            }\n          },\n          { once: true }\n        )\n      }\n    })\n    // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n    // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n    // your own promise out of it you'll need to ensure you handle the error when it rejects.\n    hangingPromise.catch(ignoreReject)\n    return hangingPromise\n  }\n}\n\nfunction ignoreReject() {}\n", "const DYNAMIC_ERROR_CODE = 'DYNAMIC_SERVER_USAGE'\n\nexport class DynamicServerError extends Error {\n  digest: typeof DYNAMIC_ERROR_CODE = DYNAMIC_ERROR_CODE\n\n  constructor(public readonly description: string) {\n    super(`Dynamic server usage: ${description}`)\n  }\n}\n\nexport function isDynamicServerError(err: unknown): err is DynamicServerError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === DYNAMIC_ERROR_CODE\n}\n", "const NEXT_STATIC_GEN_BAILOUT = 'NEXT_STATIC_GEN_BAILOUT'\n\nexport class StaticGenBailoutError extends Error {\n  public readonly code = NEXT_STATIC_GEN_BAILOUT\n}\n\nexport function isStaticGenBailoutError(\n  error: unknown\n): error is StaticGenBailoutError {\n  if (typeof error !== 'object' || error === null || !('code' in error)) {\n    return false\n  }\n\n  return error.code === NEXT_STATIC_GEN_BAILOUT\n}\n", "import type { AsyncLocalStorage } from 'async_hooks'\n\nconst sharedAsyncLocalStorageNotAvailableError = new Error(\n  'Invariant: AsyncLocalStorage accessed in runtime where it is not available'\n)\n\nclass FakeAsyncLocalStorage<Store extends {}>\n  implements AsyncLocalStorage<Store>\n{\n  disable(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  getStore(): Store | undefined {\n    // This fake implementation of AsyncLocalStorage always returns `undefined`.\n    return undefined\n  }\n\n  run<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  exit<R>(): R {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  enterWith(): void {\n    throw sharedAsyncLocalStorageNotAvailableError\n  }\n\n  static bind<T>(fn: T): T {\n    return fn\n  }\n}\n\nconst maybeGlobalAsyncLocalStorage =\n  typeof globalThis !== 'undefined' && (globalThis as any).AsyncLocalStorage\n\nexport function createAsyncLocalStorage<\n  Store extends {},\n>(): AsyncLocalStorage<Store> {\n  if (maybeGlobalAsyncLocalStorage) {\n    return new maybeGlobalAsyncLocalStorage()\n  }\n  return new FakeAsyncLocalStorage()\n}\n\nexport function bindSnapshot<T>(fn: T): T {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.bind(fn)\n  }\n  return FakeAsyncLocalStorage.bind(fn)\n}\n\nexport function createSnapshot(): <R, TArgs extends any[]>(\n  fn: (...args: TArgs) => R,\n  ...args: TArgs\n) => R {\n  if (maybeGlobalAsyncLocalStorage) {\n    return maybeGlobalAsyncLocalStorage.snapshot()\n  }\n  return function (fn: any, ...args: any[]) {\n    return fn(...args)\n  }\n}\n", "import { createAsyncLocalStorage } from './async-local-storage'\nimport type { WorkUnitAsyncStorage } from './work-unit-async-storage.external'\n\nexport const workUnitAsyncStorageInstance: WorkUnitAsyncStorage =\n  createAsyncLocalStorage()\n", "export const RSC_HEADER = 'RSC' as const\nexport const ACTION_HEADER = 'Next-Action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'Next-Router-State-Tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'Next-Router-Prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change Next-Router-State-Tree to be a segment path, we can use\n// that instead. Then Next-Router-Prefetch and Next-Router-Segment-Prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'Next-Router-Segment-Prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'Next-HMR-Refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'Next-Url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\n", "import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\nimport type { ImplicitTags } from '../lib/implicit-tags'\nimport type { WorkStore } from './work-async-storage.external'\nimport { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers'\n\nexport type WorkUnitPhase = 'action' | 'render' | 'after'\n\nexport interface CommonWorkUnitStore {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n  readonly implicitTags: ImplicitTags\n}\n\nexport interface RequestStore extends CommonWorkUnitStore {\n  type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  prerenderPhase?: boolean\n}\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport interface PrerenderStoreModern extends CommonWorkUnitStore {\n  type: 'prerender'\n\n  /**\n   * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n   */\n  readonly renderSignal: AbortSignal\n  /**\n   * This is the AbortController which represents the boundary between Prerender and dynamic. In some renders it is\n   * the same as the controller for the renderSignal but in others it is a separate controller. It should be aborted\n   * whenever the we are no longer in the prerender phase of rendering. Typically this is after one task or when you call\n   * a sync API which requires the prerender to end immediately\n   */\n  readonly controller: AbortController\n\n  /**\n   * when not null this signal is used to track cache reads during prerendering and\n   * to await all cache reads completing before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  // DEV ONLY\n  // When used this flag informs certain APIs to skip logging because we're\n  // not part of the primary render path and are just prerendering to produce\n  // validation results\n  validating?: boolean\n\n  /**\n   * The HMR refresh hash is only provided in dev mode. It is needed for the dev\n   * warmup render to ensure that the cache keys will be identical for the\n   * subsequent dynamic render.\n   */\n  readonly hmrRefreshHash: string | undefined\n}\n\nexport interface PrerenderStorePPR extends CommonWorkUnitStore {\n  type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly dynamicTracking: null | DynamicTrackingState\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n}\n\nexport interface PrerenderStoreLegacy extends CommonWorkUnitStore {\n  type: 'prerender-legacy'\n  readonly rootParams: Params\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n}\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\nexport interface CommonCacheStore\n  extends Omit<CommonWorkUnitStore, 'implicitTags'> {\n  /**\n   * A cache work unit store might not always have an outer work unit store,\n   * from which implicit tags could be inherited.\n   */\n  readonly implicitTags: ImplicitTags | undefined\n}\n\nexport interface UseCacheStore extends CommonCacheStore {\n  type: 'cache'\n  // Collected revalidate times and tags for this cache entry during the cache render.\n  revalidate: number // implicit revalidate time from inner caches / fetches\n  expire: number // server expiration time\n  stale: number // client expiration time\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  tags: null | string[]\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n  // Draft mode is only available if the outer work unit store is a request\n  // store and draft mode is enabled.\n  readonly draftMode: DraftModeProvider | undefined\n}\n\nexport interface UnstableCacheStore extends CommonCacheStore {\n  type: 'unstable-cache'\n  // Draft mode is only available if the outer work unit store is a request\n  // store and draft mode is enabled.\n  readonly draftMode: DraftModeProvider | undefined\n}\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or unstable_cache context.\n * Inside this context we should never expose any request or page specific information.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function getExpectedRequestStore(\n  callingExpression: string\n): RequestStore {\n  const workUnitStore = workUnitAsyncStorageInstance.getStore()\n\n  if (!workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'request':\n      return workUnitStore\n\n    case 'prerender':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // This should not happen because we should have checked it already.\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside a prerender. This is a bug in Next.js.`\n      )\n\n    case 'cache':\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside \"use cache\". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache`\n      )\n\n    case 'unstable-cache':\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n      )\n\n    default:\n      const _exhaustiveCheck: never = workUnitStore\n      return _exhaustiveCheck\n  }\n}\n\nexport function throwForMissingRequestStore(callingExpression: string): never {\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  if (\n    workUnitStore.type === 'prerender' ||\n    workUnitStore.type === 'prerender-ppr'\n  ) {\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  if (\n    workUnitStore.type !== 'prerender-legacy' &&\n    workUnitStore.type !== 'cache' &&\n    workUnitStore.type !== 'unstable-cache'\n  ) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore.renderResumeDataCache\n    }\n\n    // We return the mutable resume data cache here as an immutable version of\n    // the cache as it can also be used for reading.\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getHmrRefreshHash(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  if (!workStore.dev) {\n    return undefined\n  }\n\n  return workUnitStore.type === 'cache' || workUnitStore.type === 'prerender'\n    ? workUnitStore.hmrRefreshHash\n    : workUnitStore.type === 'request'\n      ? workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n      : undefined\n}\n\n/**\n * Returns a draft mode provider only if draft mode is enabled.\n */\nexport function getDraftModeProviderForCacheScope(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): DraftModeProvider | undefined {\n  if (workStore.isDraftMode) {\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'unstable-cache':\n      case 'request':\n        return workUnitStore.draftMode\n      default:\n        return undefined\n    }\n  }\n\n  return undefined\n}\n", "import type { WorkAsyncStorage } from './work-async-storage.external'\nimport { createAsyncLocalStorage } from './async-local-storage'\n\nexport const workAsyncStorageInstance: WorkAsyncStorage =\n  createAsyncLocalStorage()\n", "import type { AsyncLocalStorage } from 'async_hooks'\nimport type { IncrementalCache } from '../lib/incremental-cache'\nimport type { FetchMetrics } from '../base-http'\nimport type { FallbackRouteParams } from '../request/fallback-params'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport type { AppSegmentConfig } from '../../build/segment-config/app/app-segment-config'\nimport type { AfterContext } from '../after/after-context'\nimport type { CacheLife } from '../use-cache/cache-life'\n\n// Share the instance module in the next-shared layer\nimport { workAsyncStorageInstance } from './work-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { LazyResult } from '../lib/lazy-result'\n\nexport interface WorkStore {\n  readonly isStaticGeneration: boolean\n\n  /**\n   * The page that is being rendered. This relates to the path to the page file.\n   */\n  readonly page: string\n\n  /**\n   * The route that is being rendered. This is the page property without the\n   * trailing `/page` or `/route` suffix.\n   */\n  readonly route: string\n\n  /**\n   * The set of unknown route parameters. Accessing these will be tracked as\n   * a dynamic access.\n   */\n  readonly fallbackRouteParams: FallbackRouteParams | null\n\n  readonly incrementalCache?: IncrementalCache\n  readonly cacheLifeProfiles?: { [profile: string]: CacheLife }\n\n  readonly isOnDemandRevalidate?: boolean\n  readonly isPrerendering?: boolean\n  readonly isRevalidate?: boolean\n\n  forceDynamic?: boolean\n  fetchCache?: AppSegmentConfig['fetchCache']\n\n  forceStatic?: boolean\n  dynamicShouldError?: boolean\n  pendingRevalidates?: Record<string, Promise<any>>\n  pendingRevalidateWrites?: Array<Promise<void>> // This is like pendingRevalidates but isn't used for deduping.\n  readonly afterContext: AfterContext\n\n  dynamicUsageDescription?: string\n  dynamicUsageStack?: string\n\n  /**\n   * Invalid usage errors might be caught in userland. We attach them to the\n   * work store to ensure we can still fail the build or dev render.\n   */\n  // TODO: Collect an array of errors, and throw as AggregateError when\n  // `serializeError` and the Dev Overlay support it.\n  invalidUsageError?: Error\n\n  nextFetchId?: number\n  pathWasRevalidated?: boolean\n\n  /**\n   * Tags that were revalidated during the current request. They need to be sent\n   * to cache handlers to propagate their revalidation.\n   */\n  pendingRevalidatedTags?: string[]\n\n  /**\n   * Tags that were previously revalidated (e.g. by a redirecting server action)\n   * and have already been sent to cache handlers. Retrieved cache entries that\n   * include any of these tags must be discarded.\n   */\n  readonly previouslyRevalidatedTags: readonly string[]\n\n  /**\n   * This map contains lazy results so that we can evaluate them when the first\n   * cache entry is read. It allows us to skip refreshing tags if no caches are\n   * read at all.\n   */\n  readonly refreshTagsByCacheKind: Map<string, LazyResult<void>>\n\n  fetchMetrics?: FetchMetrics\n\n  isDraftMode?: boolean\n  isUnstableNoStore?: boolean\n  isPrefetchRequest?: boolean\n\n  requestEndedState?: { ended?: boolean }\n\n  buildId: string\n\n  readonly reactLoadableManifest?: DeepReadonly<\n    Record<string, { files: string[] }>\n  >\n  readonly assetPrefix?: string\n\n  dynamicIOEnabled: boolean\n  dev: boolean\n}\n\nexport type WorkAsyncStorage = AsyncLocalStorage<WorkStore>\n\nexport { workAsyncStorageInstance as workAsyncStorage }\n", "export type ScheduledFn<T = void> = () => T | PromiseLike<T>\nexport type SchedulerFn<T = void> = (cb: ScheduledFn<T>) => void\n\n/**\n * Schedules a function to be called on the next tick after the other promises\n * have been resolved.\n *\n * @param cb the function to schedule\n */\nexport const scheduleOnNextTick = <T = void>(cb: ScheduledFn<T>): void => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    if (process.env.NEXT_RUNTIME === 'edge') {\n      setTimeout(cb, 0)\n    } else {\n      process.nextTick(cb)\n    }\n  })\n}\n\n/**\n * Schedules a function to be called using `setImmediate` or `setTimeout` if\n * `setImmediate` is not available (like in the Edge runtime).\n *\n * @param cb the function to schedule\n */\nexport const scheduleImmediate = <T = void>(cb: ScheduledFn<T>): void => {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    setTimeout(cb, 0)\n  } else {\n    setImmediate(cb)\n  }\n}\n\n/**\n * returns a promise than resolves in a future task. There is no guarantee that the task it resolves in\n * will be the next task but if you await it you can at least be sure that the current task is over and\n * most usefully that the entire microtask queue of the current task has been emptied.\n */\nexport function atLeastOneTask() {\n  return new Promise<void>((resolve) => scheduleImmediate(resolve))\n}\n\n/**\n * This utility function is extracted to make it easier to find places where we are doing\n * specific timing tricks to try to schedule work after React has rendered. This is especially\n * important at the moment because Next.js uses the edge builds of React which use setTimeout to\n * schedule work when you might expect that something like setImmediate would do the trick.\n *\n * Long term we should switch to the node versions of React rendering when possible and then\n * update this to use setImmediate rather than setTimeout\n */\nexport function waitAtLeastOneReactRenderTask(): Promise<void> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    return new Promise((r) => setTimeout(r, 0))\n  } else {\n    return new Promise((r) => setImmediate(r))\n  }\n}\n", "export const METADATA_BOUNDARY_NAME = '__next_metadata_boundary__'\nexport const VIEWPORT_BOUNDARY_NAME = '__next_viewport_boundary__'\nexport const OUTLET_BOUNDARY_NAME = '__next_outlet_boundary__'\n", "/**\n * The functions provided by this module are used to communicate certain properties\n * about the currently running code so that Next.js can make decisions on how to handle\n * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.\n *\n * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.\n * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts\n * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of\n * Dynamic indications.\n *\n * The first is simply an intention to be dynamic. unstable_noStore is an example of this where\n * the currently executing code simply declares that the current scope is dynamic but if you use it\n * inside unstable_cache it can still be cached. This type of indication can be removed if we ever\n * make the default dynamic to begin with because the only way you would ever be static is inside\n * a cache scope which this indication does not affect.\n *\n * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic\n * because it means that it is inappropriate to cache this at all. using a dynamic data source inside\n * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should\n * read that data outside the cache and pass it in as an argument to the cached function.\n */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport type {\n  WorkUnitStore,\n  RequestStore,\n  PrerenderStoreLegacy,\n  PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\n\n// Once postpone is in stable we should switch to importing the postpone export directly\nimport React from 'react'\n\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { workUnitAsyncStorage } from './work-unit-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport {\n  METADATA_BOUNDARY_NAME,\n  VIEWPORT_BOUNDARY_NAME,\n  OUTLET_BOUNDARY_NAME,\n} from '../../lib/metadata/metadata-constants'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\n\nconst hasPostpone = typeof React.unstable_postpone === 'function'\n\nexport type DynamicAccess = {\n  /**\n   * If debugging, this will contain the stack trace of where the dynamic access\n   * occurred. This is used to provide more information to the user about why\n   * their page is being rendered dynamically.\n   */\n  stack?: string\n\n  /**\n   * The expression that was accessed dynamically.\n   */\n  expression: string\n}\n\n// Stores dynamic reasons used during an RSC render.\nexport type DynamicTrackingState = {\n  /**\n   * When true, stack information will also be tracked during dynamic access.\n   */\n  readonly isDebugDynamicAccesses: boolean | undefined\n\n  /**\n   * The dynamic accesses that occurred during the render.\n   */\n  readonly dynamicAccesses: Array<DynamicAccess>\n\n  syncDynamicExpression: undefined | string\n  syncDynamicErrorWithStack: null | Error\n  // Dev only\n  syncDynamicLogged?: boolean\n}\n\n// Stores dynamic reasons used during an SSR render.\nexport type DynamicValidationState = {\n  hasSuspendedDynamic: boolean\n  hasDynamicMetadata: boolean\n  hasDynamicViewport: boolean\n  hasSyncDynamicErrors: boolean\n  dynamicErrors: Array<Error>\n}\n\nexport function createDynamicTrackingState(\n  isDebugDynamicAccesses: boolean | undefined\n): DynamicTrackingState {\n  return {\n    isDebugDynamicAccesses,\n    dynamicAccesses: [],\n    syncDynamicExpression: undefined,\n    syncDynamicErrorWithStack: null,\n  }\n}\n\nexport function createDynamicValidationState(): DynamicValidationState {\n  return {\n    hasSuspendedDynamic: false,\n    hasDynamicMetadata: false,\n    hasDynamicViewport: false,\n    hasSyncDynamicErrors: false,\n    dynamicErrors: [],\n  }\n}\n\nexport function getFirstDynamicReason(\n  trackingState: DynamicTrackingState\n): undefined | string {\n  return trackingState.dynamicAccesses[0]?.expression\n}\n\n/**\n * This function communicates that the current scope should be treated as dynamic.\n *\n * In most cases this function is a no-op but if called during\n * a PPR prerender it will postpone the current sub-tree and calling\n * it during a normal prerender will cause the entire prerender to abort\n */\nexport function markCurrentScopeAsDynamic(\n  store: WorkStore,\n  workUnitStore: undefined | Exclude<WorkUnitStore, PrerenderStoreModern>,\n  expression: string\n): void {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n  }\n\n  // If we're forcing dynamic rendering or we're forcing static rendering, we\n  // don't need to do anything here because the entire page is already dynamic\n  // or it's static and it should not throw or postpone here.\n  if (store.forceDynamic || store.forceStatic) return\n\n  if (store.dynamicShouldError) {\n    throw new StaticGenBailoutError(\n      `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n    )\n  }\n\n  if (workUnitStore) {\n    if (workUnitStore.type === 'prerender-ppr') {\n      postponeWithTracking(\n        store.route,\n        expression,\n        workUnitStore.dynamicTracking\n      )\n    } else if (workUnitStore.type === 'prerender-legacy') {\n      workUnitStore.revalidate = 0\n\n      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n      const err = new DynamicServerError(\n        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n      )\n      store.dynamicUsageDescription = expression\n      store.dynamicUsageStack = err.stack\n\n      throw err\n    } else if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n/**\n * This function communicates that some dynamic path parameter was read. This\n * differs from the more general `trackDynamicDataAccessed` in that it is will\n * not error when `dynamic = \"error\"` is set.\n *\n * @param store The static generation store\n * @param expression The expression that was accessed dynamically\n */\nexport function trackFallbackParamAccessed(\n  store: WorkStore,\n  expression: string\n): void {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n\n  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n}\n\n/**\n * This function is meant to be used when prerendering without dynamicIO or PPR.\n * When called during a build it will cause Next.js to consider the route as dynamic.\n *\n * @internal\n */\nexport function throwToInterruptStaticGeneration(\n  expression: string,\n  store: WorkStore,\n  prerenderStore: PrerenderStoreLegacy\n): never {\n  // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n  const err = new DynamicServerError(\n    `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n  )\n\n  prerenderStore.revalidate = 0\n\n  store.dynamicUsageDescription = expression\n  store.dynamicUsageStack = err.stack\n\n  throw err\n}\n\n/**\n * This function should be used to track whether something dynamic happened even when\n * we are in a dynamic render. This is useful for Dev where all renders are dynamic but\n * we still track whether dynamic APIs were accessed for helpful messaging\n *\n * @internal\n */\nexport function trackDynamicDataInDynamicRender(\n  _store: WorkStore,\n  workUnitStore: void | WorkUnitStore\n) {\n  if (workUnitStore) {\n    if (\n      workUnitStore.type === 'cache' ||\n      workUnitStore.type === 'unstable-cache'\n    ) {\n      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n      // forbidden inside a cache scope.\n      return\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      workUnitStore.revalidate = 0\n    }\n    if (\n      process.env.NODE_ENV === 'development' &&\n      workUnitStore.type === 'request'\n    ) {\n      workUnitStore.usedDynamic = true\n    }\n  }\n}\n\n// Despite it's name we don't actually abort unless we have a controller to call abort on\n// There are times when we let a prerender run long to discover caches where we want the semantics\n// of tracking dynamic access without terminating the prerender early\nfunction abortOnSynchronousDynamicDataAccess(\n  route: string,\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n\n  const error = createPrerenderInterruptedError(reason)\n\n  prerenderStore.controller.abort(error)\n\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function abortOnSynchronousPlatformIOAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): void {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    if (dynamicTracking.syncDynamicErrorWithStack === null) {\n      dynamicTracking.syncDynamicExpression = expression\n      dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n    }\n  }\n  abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n}\n\nexport function trackSynchronousPlatformIOAccessInDev(\n  requestStore: RequestStore\n): void {\n  // We don't actually have a controller to abort but we do the semantic equivalent by\n  // advancing the request store out of prerender mode\n  requestStore.prerenderPhase = false\n}\n\n/**\n * use this function when prerendering with dynamicIO. If we are doing a\n * prospective prerender we don't actually abort because we want to discover\n * all caches for the shell. If this is the actual prerender we do abort.\n *\n * This function accepts a prerenderStore but the caller should ensure we're\n * actually running in dynamicIO mode.\n *\n * @internal\n */\nexport function abortAndThrowOnSynchronousRequestDataAccess(\n  route: string,\n  expression: string,\n  errorWithStack: Error,\n  prerenderStore: PrerenderStoreModern\n): never {\n  const prerenderSignal = prerenderStore.controller.signal\n  if (prerenderSignal.aborted === false) {\n    // TODO it would be better to move this aborted check into the callsite so we can avoid making\n    // the error object when it isn't relevant to the aborting of the prerender however\n    // since we need the throw semantics regardless of whether we abort it is easier to land\n    // this way. See how this was handled with `abortOnSynchronousPlatformIOAccess` for a closer\n    // to ideal implementation\n    const dynamicTracking = prerenderStore.dynamicTracking\n    if (dynamicTracking) {\n      if (dynamicTracking.syncDynamicErrorWithStack === null) {\n        dynamicTracking.syncDynamicExpression = expression\n        dynamicTracking.syncDynamicErrorWithStack = errorWithStack\n        if (prerenderStore.validating === true) {\n          // We always log Request Access in dev at the point of calling the function\n          // So we mark the dynamic validation as not requiring it to be printed\n          dynamicTracking.syncDynamicLogged = true\n        }\n      }\n    }\n    abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore)\n  }\n  throw createPrerenderInterruptedError(\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`\n  )\n}\n\n// For now these implementations are the same so we just reexport\nexport const trackSynchronousRequestDataAccessInDev =\n  trackSynchronousPlatformIOAccessInDev\n\n/**\n * This component will call `React.postpone` that throws the postponed error.\n */\ntype PostponeProps = {\n  reason: string\n  route: string\n}\nexport function Postpone({ reason, route }: PostponeProps): never {\n  const prerenderStore = workUnitAsyncStorage.getStore()\n  const dynamicTracking =\n    prerenderStore && prerenderStore.type === 'prerender-ppr'\n      ? prerenderStore.dynamicTracking\n      : null\n  postponeWithTracking(route, reason, dynamicTracking)\n}\n\nexport function postponeWithTracking(\n  route: string,\n  expression: string,\n  dynamicTracking: null | DynamicTrackingState\n): never {\n  assertPostpone()\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      // When we aren't debugging, we don't need to create another error for the\n      // stack trace.\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n\n  React.unstable_postpone(createPostponeReason(route, expression))\n}\n\nfunction createPostponeReason(route: string, expression: string) {\n  return (\n    `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. ` +\n    `React throws this special object to indicate where. It should not be caught by ` +\n    `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`\n  )\n}\n\nexport function isDynamicPostpone(err: unknown) {\n  if (\n    typeof err === 'object' &&\n    err !== null &&\n    typeof (err as any).message === 'string'\n  ) {\n    return isDynamicPostponeReason((err as any).message)\n  }\n  return false\n}\n\nfunction isDynamicPostponeReason(reason: string) {\n  return (\n    reason.includes(\n      'needs to bail out of prerendering at this point because it used'\n    ) &&\n    reason.includes(\n      'Learn more: https://nextjs.org/docs/messages/ppr-caught-error'\n    )\n  )\n}\n\nif (isDynamicPostponeReason(createPostponeReason('%%%', '^^^')) === false) {\n  throw new Error(\n    'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'\n  )\n}\n\nconst NEXT_PRERENDER_INTERRUPTED = 'NEXT_PRERENDER_INTERRUPTED'\n\nfunction createPrerenderInterruptedError(message: string): Error {\n  const error = new Error(message)\n  ;(error as any).digest = NEXT_PRERENDER_INTERRUPTED\n  return error\n}\n\ntype DigestError = Error & {\n  digest: string\n}\n\nexport function isPrerenderInterruptedError(\n  error: unknown\n): error is DigestError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    (error as any).digest === NEXT_PRERENDER_INTERRUPTED &&\n    'name' in error &&\n    'message' in error &&\n    error instanceof Error\n  )\n}\n\nexport function accessedDynamicData(\n  dynamicAccesses: Array<DynamicAccess>\n): boolean {\n  return dynamicAccesses.length > 0\n}\n\nexport function consumeDynamicAccess(\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): DynamicTrackingState['dynamicAccesses'] {\n  // We mutate because we only call this once we are no longer writing\n  // to the dynamicTrackingState and it's more efficient than creating a new\n  // array.\n  serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses)\n  return serverDynamic.dynamicAccesses\n}\n\nexport function formatDynamicAPIAccesses(\n  dynamicAccesses: Array<DynamicAccess>\n): string[] {\n  return dynamicAccesses\n    .filter(\n      (access): access is Required<DynamicAccess> =>\n        typeof access.stack === 'string' && access.stack.length > 0\n    )\n    .map(({ expression, stack }) => {\n      stack = stack\n        .split('\\n')\n        // Remove the \"Error: \" prefix from the first line of the stack trace as\n        // well as the first 4 lines of the stack trace which is the distance\n        // from the user code and the `new Error().stack` call.\n        .slice(4)\n        .filter((line) => {\n          // Exclude Next.js internals from the stack trace.\n          if (line.includes('node_modules/next/')) {\n            return false\n          }\n\n          // Exclude anonymous functions from the stack trace.\n          if (line.includes(' (<anonymous>)')) {\n            return false\n          }\n\n          // Exclude Node.js internals from the stack trace.\n          if (line.includes(' (node:')) {\n            return false\n          }\n\n          return true\n        })\n        .join('\\n')\n      return `Dynamic API Usage Debug - ${expression}:\\n${stack}`\n    })\n}\n\nfunction assertPostpone() {\n  if (!hasPostpone) {\n    throw new Error(\n      `Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`\n    )\n  }\n}\n\n/**\n * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's\n * abort semantics slightly.\n */\nexport function createPostponedAbortSignal(reason: string): AbortSignal {\n  assertPostpone()\n  const controller = new AbortController()\n  // We get our hands on a postpone instance by calling postpone and catching the throw\n  try {\n    React.unstable_postpone(reason)\n  } catch (x: unknown) {\n    controller.abort(x)\n  }\n  return controller.signal\n}\n\n/**\n * In a prerender, we may end up with hanging Promises as inputs due them\n * stalling on connection() or because they're loading dynamic data. In that\n * case we need to abort the encoding of arguments since they'll never complete.\n */\nexport function createHangingInputAbortSignal(\n  workUnitStore: PrerenderStoreModern\n): AbortSignal {\n  const controller = new AbortController()\n\n  if (workUnitStore.cacheSignal) {\n    // If we have a cacheSignal it means we're in a prospective render. If the input\n    // we're waiting on is coming from another cache, we do want to wait for it so that\n    // we can resolve this cache entry too.\n    workUnitStore.cacheSignal.inputReady().then(() => {\n      controller.abort()\n    })\n  } else {\n    // Otherwise we're in the final render and we should already have all our caches\n    // filled. We might still be waiting on some microtasks so we wait one tick before\n    // giving up. When we give up, we still want to render the content of this cache\n    // as deeply as we can so that we can suspend as deeply as possible in the tree\n    // or not at all if we don't end up waiting for the input.\n    scheduleOnNextTick(() => controller.abort())\n  }\n\n  return controller.signal\n}\n\nexport function annotateDynamicAccess(\n  expression: string,\n  prerenderStore: PrerenderStoreModern\n) {\n  const dynamicTracking = prerenderStore.dynamicTracking\n  if (dynamicTracking) {\n    dynamicTracking.dynamicAccesses.push({\n      stack: dynamicTracking.isDebugDynamicAccesses\n        ? new Error().stack\n        : undefined,\n      expression,\n    })\n  }\n}\n\nexport function useDynamicRouteParams(expression: string) {\n  const workStore = workAsyncStorage.getStore()\n\n  if (\n    workStore &&\n    workStore.isStaticGeneration &&\n    workStore.fallbackRouteParams &&\n    workStore.fallbackRouteParams.size > 0\n  ) {\n    // There are fallback route params, we should track these as dynamic\n    // accesses.\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    if (workUnitStore) {\n      // We're prerendering with dynamicIO or PPR or both\n      if (workUnitStore.type === 'prerender') {\n        // We are in a prerender with dynamicIO semantics\n        // We are going to hang here and never resolve. This will cause the currently\n        // rendering component to effectively be a dynamic hole\n        React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // We're prerendering with PPR\n        postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n      }\n    }\n  }\n}\n\nconst hasSuspenseRegex = /\\n\\s+at Suspense \\(<anonymous>\\)/\nconst hasMetadataRegex = new RegExp(\n  `\\\\n\\\\s+at ${METADATA_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasViewportRegex = new RegExp(\n  `\\\\n\\\\s+at ${VIEWPORT_BOUNDARY_NAME}[\\\\n\\\\s]`\n)\nconst hasOutletRegex = new RegExp(`\\\\n\\\\s+at ${OUTLET_BOUNDARY_NAME}[\\\\n\\\\s]`)\n\nexport function trackAllowedDynamicAccess(\n  route: string,\n  componentStack: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n) {\n  if (hasOutletRegex.test(componentStack)) {\n    // We don't need to track that this is dynamic. It is only so when something else is also dynamic.\n    return\n  } else if (hasMetadataRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicMetadata = true\n    return\n  } else if (hasViewportRegex.test(componentStack)) {\n    dynamicValidation.hasDynamicViewport = true\n    return\n  } else if (hasSuspenseRegex.test(componentStack)) {\n    dynamicValidation.hasSuspendedDynamic = true\n    return\n  } else if (\n    serverDynamic.syncDynamicErrorWithStack ||\n    clientDynamic.syncDynamicErrorWithStack\n  ) {\n    dynamicValidation.hasSyncDynamicErrors = true\n    return\n  } else {\n    const message = `Route \"${route}\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don't have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`\n    const error = createErrorWithComponentStack(message, componentStack)\n    dynamicValidation.dynamicErrors.push(error)\n    return\n  }\n}\n\nfunction createErrorWithComponentStack(\n  message: string,\n  componentStack: string\n) {\n  const error = new Error(message)\n  error.stack = 'Error: ' + message + componentStack\n  return error\n}\n\nexport function throwIfDisallowedDynamic(\n  route: string,\n  dynamicValidation: DynamicValidationState,\n  serverDynamic: DynamicTrackingState,\n  clientDynamic: DynamicTrackingState\n): void {\n  let syncError: null | Error\n  let syncExpression: undefined | string\n  let syncLogged: boolean\n  if (serverDynamic.syncDynamicErrorWithStack) {\n    syncError = serverDynamic.syncDynamicErrorWithStack\n    syncExpression = serverDynamic.syncDynamicExpression!\n    syncLogged = serverDynamic.syncDynamicLogged === true\n  } else if (clientDynamic.syncDynamicErrorWithStack) {\n    syncError = clientDynamic.syncDynamicErrorWithStack\n    syncExpression = clientDynamic.syncDynamicExpression!\n    syncLogged = clientDynamic.syncDynamicLogged === true\n  } else {\n    syncError = null\n    syncExpression = undefined\n    syncLogged = false\n  }\n\n  if (dynamicValidation.hasSyncDynamicErrors && syncError) {\n    if (!syncLogged) {\n      // In dev we already log errors about sync dynamic access. But during builds we need to ensure\n      // the offending sync error is logged before we exit the build\n      console.error(syncError)\n    }\n    // The actual error should have been logged when the sync access ocurred\n    throw new StaticGenBailoutError()\n  }\n\n  const dynamicErrors = dynamicValidation.dynamicErrors\n  if (dynamicErrors.length) {\n    for (let i = 0; i < dynamicErrors.length; i++) {\n      console.error(dynamicErrors[i])\n    }\n\n    throw new StaticGenBailoutError()\n  }\n\n  if (!dynamicValidation.hasSuspendedDynamic) {\n    if (dynamicValidation.hasDynamicMetadata) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateMetadata\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateMetadata\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    } else if (dynamicValidation.hasDynamicViewport) {\n      if (syncError) {\n        console.error(syncError)\n        throw new StaticGenBailoutError(\n          `Route \"${route}\" has a \\`generateViewport\\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`\n        )\n      }\n      throw new StaticGenBailoutError(\n        `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or external data (\\`fetch(...)\\`, etc...) but the rest of the route was static or only used cached data (\\`\"use cache\"\\`). If you expected this route to be prerenderable update your \\`generateViewport\\` to not use Request data and only use cached external data. Otherwise, add \\`await connection()\\` somewhere within this route to indicate explicitly it should not be prerendered.`\n      )\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["isHangingPromiseRejectionError", "makeHangingPromise", "err", "digest", "HANGING_PROMISE_REJECTION", "HangingPromiseRejectionError", "Error", "constructor", "expression", "abortListenersBySignal", "WeakMap", "signal", "aborted", "Promise", "reject", "hangingPromise", "_", "boundRejection", "bind", "currentListeners", "get", "push", "listeners", "set", "addEventListener", "i", "length", "once", "catch", "ignoreReject", "DynamicServerError", "isDynamicServerError", "DYNAMIC_ERROR_CODE", "Error", "constructor", "description", "digest", "err", "StaticGenBailoutError", "isStaticGenBailoutError", "NEXT_STATIC_GEN_BAILOUT", "Error", "code", "error", "bindSnapshot", "createAsyncLocalStorage", "createSnapshot", "sharedAsyncLocalStorageNotAvailableError", "Error", "FakeAsyncLocalStorage", "disable", "getStore", "undefined", "run", "exit", "enterWith", "bind", "fn", "maybeGlobalAsyncLocalStorage", "globalThis", "AsyncLocalStorage", "snapshot", "args", "workUnitAsyncStorageInstance", "createAsyncLocalStorage", "ACTION_HEADER", "FLIGHT_HEADERS", "NEXT_DID_POSTPONE_HEADER", "NEXT_HMR_REFRESH_HASH_COOKIE", "NEXT_HMR_REFRESH_HEADER", "NEXT_IS_PRERENDER_HEADER", "NEXT_REWRITTEN_PATH_HEADER", "NEXT_REWRITTEN_QUERY_HEADER", "NEXT_ROUTER_PREFETCH_HEADER", "NEXT_ROUTER_SEGMENT_PREFETCH_HEADER", "NEXT_ROUTER_STALE_TIME_HEADER", "NEXT_ROUTER_STATE_TREE_HEADER", "NEXT_RSC_UNION_QUERY", "NEXT_URL", "RSC_CONTENT_TYPE_HEADER", "RSC_HEADER", "getDraftModeProviderForCacheScope", "getExpectedRequestStore", "getHmrRefreshHash", "getPrerenderResumeDataCache", "getRenderResumeDataCache", "throwForMissingRequestStore", "workUnitAsyncStorage", "workUnitAsyncStorageInstance", "callingExpression", "workUnitStore", "getStore", "type", "Error", "_exhaustiveCheck", "prerenderResumeDataCache", "renderResumeDataCache", "workStore", "dev", "undefined", "hmrRefreshHash", "cookies", "get", "NEXT_HMR_REFRESH_HASH_COOKIE", "value", "isDraftMode", "draftMode", "workAsyncStorageInstance", "createAsyncLocalStorage", "workAsyncStorage", "workAsyncStorageInstance", "atLeastOneTask", "scheduleImmediate", "scheduleOnNextTick", "waitAtLeastOneReactRenderTask", "cb", "Promise", "resolve", "then", "process", "env", "NEXT_RUNTIME", "setTimeout", "nextTick", "setImmediate", "r", "METADATA_BOUNDARY_NAME", "OUTLET_BOUNDARY_NAME", "VIEWPORT_BOUNDARY_NAME", "Postpone", "abortAndThrowOnSynchronousRequestDataAccess", "abortOnSynchronousPlatformIOAccess", "accessedDynamicData", "annotateDynamicAccess", "consumeDynamicAccess", "createDynamicTrackingState", "createDynamicValidationState", "createHangingInputAbortSignal", "createPostponedAbortSignal", "formatDynamicAPIAccesses", "getFirstDynamicReason", "isDynamicPostpone", "isPrerenderInterruptedError", "markCurrentScopeAsDynamic", "postponeWithTracking", "throwIfDisallowedDynamic", "throwToInterruptStaticGeneration", "trackAllowedDynamicAccess", "trackDynamicDataInDynamicRender", "trackFallbackParamAccessed", "trackSynchronousPlatformIOAccessInDev", "trackSynchronousRequestDataAccessInDev", "useDynamicRouteParams", "hasPostpone", "React", "unstable_postpone", "isDebugDynamicAccesses", "dynamicAccesses", "syncDynamicExpression", "undefined", "syncDynamicErrorWithStack", "hasSuspendedDynamic", "hasDynamicMetadata", "hasDynamicViewport", "hasSyncDynamicErrors", "dynamicErrors", "trackingState", "expression", "store", "workUnitStore", "type", "forceDynamic", "forceStatic", "dynamicShouldError", "StaticGenBailoutError", "route", "dynamicTracking", "revalidate", "err", "DynamicServerError", "dynamicUsageDescription", "dynamicUsageStack", "stack", "usedDynamic", "prerenderStore", "workUnitAsyncStorage", "getStore", "_store", "abortOnSynchronousDynamicDataAccess", "reason", "error", "createPrerenderInterruptedError", "controller", "abort", "push", "Error", "errorWithStack", "requestStore", "prerenderPhase", "prerenderSignal", "signal", "aborted", "validating", "syncDynamicLogged", "assertPostpone", "createPostponeReason", "message", "isDynamicPostponeReason", "includes", "NEXT_PRERENDER_INTERRUPTED", "digest", "length", "serverDynamic", "clientDynamic", "filter", "access", "map", "split", "slice", "line", "join", "AbortController", "x", "cacheSignal", "inputReady", "then", "scheduleOnNextTick", "workStore", "workAsyncStorage", "isStaticGeneration", "fallbackRouteParams", "size", "use", "makeHangingPromise", "renderSignal", "hasSuspenseRegex", "hasMetadataRegex", "RegExp", "METADATA_BOUNDARY_NAME", "hasViewportRegex", "VIEWPORT_BOUNDARY_NAME", "hasOutletRegex", "OUTLET_BOUNDARY_NAME", "componentStack", "dynamicValidation", "test", "createErrorWithComponentStack", "syncError", "syncExpression", "syncLogged", "console", "i"]
}
