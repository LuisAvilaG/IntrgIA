{
  "version": 3,
  "sources": ["../../../../node_modules/next/src/shared/lib/router-context.shared-runtime.ts", "../../../../node_modules/next/src/client/use-merged-ref.ts"],
  "sourcesContent": ["import React from 'react'\nimport type { NextRouter } from './router/router'\n\nexport const RouterContext = React.createContext<NextRouter | null>(null)\n\nif (process.env.NODE_ENV !== 'production') {\n  RouterContext.displayName = 'RouterContext'\n}\n", "import { useCallback, useRef, type Ref } from 'react'\n\n// This is a compatibility hook to support React 18 and 19 refs.\n// In 19, a cleanup function from refs may be returned.\n// In 18, returning a cleanup function creates a warning.\n// Since we take userspace refs, we don't know ahead of time if a cleanup function will be returned.\n// This implements cleanup functions with the old behavior in 18.\n// We know refs are always called alternating with `null` and then `T`.\n// So a call with `null` means we need to call the previous cleanup functions.\nexport function useMergedRef<TElement>(\n  refA: Ref<TElement>,\n  refB: Ref<TElement>\n): Ref<TElement> {\n  const cleanupA = useRef<(() => void) | null>(null)\n  const cleanupB = useRef<(() => void) | null>(null)\n\n  // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n  // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n  // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n  // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n  // (because it hasn't been updated for React 19)\n  // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n  // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n  return useCallback(\n    (current: TElement | null): void => {\n      if (current === null) {\n        const cleanupFnA = cleanupA.current\n        if (cleanupFnA) {\n          cleanupA.current = null\n          cleanupFnA()\n        }\n        const cleanupFnB = cleanupB.current\n        if (cleanupFnB) {\n          cleanupB.current = null\n          cleanupFnB()\n        }\n      } else {\n        if (refA) {\n          cleanupA.current = applyRef(refA, current)\n        }\n        if (refB) {\n          cleanupB.current = applyRef(refB, current)\n        }\n      }\n    },\n    [refA, refB]\n  )\n}\n\nfunction applyRef<TElement>(\n  refA: NonNullable<Ref<TElement>>,\n  current: TElement\n) {\n  if (typeof refA === 'function') {\n    const cleanup = refA(current)\n    if (typeof cleanup === 'function') {\n      return cleanup\n    } else {\n      return () => refA(null)\n    }\n  } else {\n    refA.current = current\n    return () => {\n      refA.current = null\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;mCAGaA,iBAAAA;;;eAAAA;;;;2DAHK;AAGX,QAAMA,gBAAgBC,OAAAA,QAAMC,cAAiC,IAAA;AAEpE,QAAIC,MAAuC;AACzCH,oBAAcI,cAAc;IAC9B;;;;;;;;;;;mCCEgBC,gBAAAA;;;eAAAA;;;;AAAT,aAASA,aACdC,MACAC,MAAmB;AAEnB,YAAMC,YAAWC,GAAAA,OAAAA,QAA4B,IAAA;AAC7C,YAAMC,YAAWD,GAAAA,OAAAA,QAA4B,IAAA;AAS7C,cAAOE,GAAAA,OAAAA,aACL,CAACC,YAAAA;AACC,YAAIA,YAAY,MAAM;AACpB,gBAAMC,aAAaL,SAASI;AAC5B,cAAIC,YAAY;AACdL,qBAASI,UAAU;AACnBC,uBAAAA;UACF;AACA,gBAAMC,aAAaJ,SAASE;AAC5B,cAAIE,YAAY;AACdJ,qBAASE,UAAU;AACnBE,uBAAAA;UACF;QACF,OAAO;AACL,cAAIR,MAAM;AACRE,qBAASI,UAAUG,SAAST,MAAMM,OAAAA;UACpC;AACA,cAAIL,MAAM;AACRG,qBAASE,UAAUG,SAASR,MAAMK,OAAAA;UACpC;QACF;MACF,GACA;QAACN;QAAMC;OAAK;IAEhB;AAEA,aAASQ,SACPT,MACAM,SAAiB;AAEjB,UAAI,OAAON,SAAS,YAAY;AAC9B,cAAMU,UAAUV,KAAKM,OAAAA;AACrB,YAAI,OAAOI,YAAY,YAAY;AACjC,iBAAOA;QACT,OAAO;AACL,iBAAO,MAAMV,KAAK,IAAA;QACpB;MACF,OAAO;AACLA,aAAKM,UAAUA;AACf,eAAO,MAAA;AACLN,eAAKM,UAAU;QACjB;MACF;IACF;;;;;;;;",
  "names": ["RouterContext", "React", "createContext", "process", "displayName", "useMergedRef", "refA", "refB", "cleanupA", "useRef", "cleanupB", "useCallback", "current", "cleanupFnA", "cleanupFnB", "applyRef", "cleanup"]
}
